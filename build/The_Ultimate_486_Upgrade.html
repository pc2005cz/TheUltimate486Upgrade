<style>
body { min-width: 80% !important; }
img {
/*    max-width:500px; */
    max-width:50%;
}
code {
  white-space : pre-wrap !important;
}
</style>
<!--<style>
body {
  font-family: "Arial", sans-serif;
}
</style>-->
<p>Created by: pc2005 (<span class="citation"
data-cites="vogons">@vogons</span> or <span class="citation"
data-cites="retroweb">@retroweb</span> discord)</p>
<h1 id="introduction">Introduction</h1>
<p>Would you like to run your 486 motherboard with a <em>really</em>
<em>good</em> configuration?</p>
<p>The story started many years ago, when I was playing with a baremetal
code (“BIOS”) for ABit AB-PB4. The project has been put on a hiatus
after I created a serial console which allowed me to poke memory and IO
space. It was even possible to manually dump sectors from CDROM, but I
lost the interest to write an API and turn the “BIOS” into a primitive
OS. Years later when I’ve discovered the Retroweb I’ve returned to the
idea while being equipped with modern tools.</p>
<p>Also with GNU/Linux.</p>
<p>NOTICE This isn’t strictly chronological.</p>
<p>NOTICE^2 Most of the blog was written using <a
href="https://theretroweb.com/motherboards/s/biostar-mb-8425uud-a">Biostar
MB-8433UUD motherboard</a>, AMD 5x86-133 and 128MB EDO DRAM.</p>
<p>Also thanks to Martes <span class="citation"
data-cites="retroweb">@retroweb</span> discord for borrowing me <a
href="https://theretroweb.com/motherboards/s/intel-classic-pci-ed-ninja">Intel
Classic/PCI ED (Ninja)</a> and a better camera.</p>
<!-- TODO overview video? -->
<h2 id="boot-the-modern-linux-on-486">Boot the modern linux on 486</h2>
<p>Let’s say we want to boot a linux distribution on a 486 motherboard.
We hit the wall even before downloading anything. The is almost none
modern distribution which is compiled for 486 architecture and if we
find a 486 compatible distribution installation image we gonna quickly
hit another wall: old BIOSes doesn’t support boot from a CD drive. The
we can set up an SD card and then we will hit the third wall: old BIOSes
doesn’t also support big drives and if they do (~ 8GB) LBA addressing
support for them is terrible.</p>
<figure>
<img src="./images/SideshowBob.png" title="Sideshow Bob"
alt="Sideshow Bob" />
<figcaption aria-hidden="true">Sideshow Bob</figcaption>
</figure>
<p>Because I like to change the things from the ground, the best
solution is to use a modern implementation of the BIOS.</p>
<h1 id="coreboot">Coreboot</h1>
<p><a href="https://www.coreboot.org/">Coreboot</a> just do the hardware
initialization and loads payloads. The hardware initialization part set
chipset’s registers, detects RAM and cache size, enumerates the PCI bus
and create system tables (SMBIOS, MP, ACPI, …). Then it can choose one
of the payloads and run it (e.g. one is a doom clone). The most
important payload is an implementation of the IBM compatible BIOS. It is
called <a href="https://www.seabios.org/SeaBIOS">SeaBIOS</a>.</p>
<p>Chronologically the first board with added support was <a
href="https://theretroweb.com/motherboards/s/abit-ab-pb4-rev-1.3">ABit
AB-PB4</a>. Thanks for my experiments years ago I could use experience
with the FinALI chipset, which is documented <a
href="https://theretroweb.com/chipsets/174#docs">here</a>.</p>
<h2 id="obtaining-the-coreboot">Obtaining the coreboot</h2>
<p>We need to download existing git repository:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> where_git_repositories_are_located</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone <span class="at">--recursive</span> https://github.com/pc2005cz/coreboot_486.git</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> coreboot_486</span></code></pre></div>
<p>Alternativelly we can clone the vanilla repo and checkout branch at
commit <code>22abb3ec33b8a877332e60889768b8d3385d5f92</code> (up to this
date):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> checkout <span class="at">-b</span> 486 22abb3ec33b8a877332e60889768b8d3385d5f92</span></code></pre></div>
<p>Then we you can apply a <a
href="https://github.com/pc2005cz/TheUltimate486Upgrade/tree/main/resources/coreboot.patch">patchset
which adds 486 support</a>.</p>
<p>We don’t need to download SeaBIOS source as the coreboot build system
will do it automatically. However if you plan to modify its sources you
will either need to set your own SeaBIOS git repository or else
everytime you do <code>make clean</code> the coreboot build system will
erase your changes.</p>
<p>Alternatively you can disable the re-checkout of the SeaBIOS git
after the first cloning by:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">--- a/payloads/external/SeaBIOS/Makefile</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">+++ b/payloads/external/SeaBIOS/Makefile</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -36,7 +36,7 @@ checkout: fetch</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    echo &quot;    Checking out SeaBIOS revision $(TAG-y)&quot;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    cd seabios; git checkout master; git branch -D coreboot 2&gt;/dev/null; git checkout -b coreboot $(TAG-y)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="st">-config: checkout</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="va">+config:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    echo &quot;    CONFIG     SeaBIOS $(TAG-y)&quot;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    echo &quot;CONFIG_COREBOOT=y&quot; &gt; seabios/.config</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a> ifeq ($(CONFIG_CONSOLE_SERIAL)$(CONFIG_DRIVERS_UART_8250IO),yy)</span></code></pre></div>
<p>When I’ve started porting 486 chipset to coreboot I’ve got lucky as I
hit the time when 586 support was still included (for Intel Quark). It
was easier to orient between all x86-64, MTRR and clflush code. In about
two releases <a
href="https://github.com/coreboot/coreboot/commit/91795a6da1c02e8af75cf52f9e28662a7947b204">the
586 support was removed</a>.</p>
<p>I don’t think there ever was any 486 support.</p>
<h2 id="how-does-bios-initialize-the-486-system">How does BIOS
initialize the 486 system</h2>
<p>Everytime a 486 processor receives a reset signal it will jump to
address 0xFFFFFFF0 (16 bytes from the top of the RAM) as start to
execute the code located here. Chipset needs to mirror at least a part
of the BIOS space to this address. There is no RAM available at this
stage, however there is an exception. The OS can reset only the CPU, the
chipset will stay configured. The main use of this mechanism is a warm
reset or a resume from standby. Also CPU can reset on an exception
(e.g. an invalid opcode, which happens very frequently during porting).
In this case the role of a BIOS is to check if the warm reboot was
requested or not. We can check that by reading a value at CMOS <a
href="https://github.com/cirosantilli/ralf-brown-interrupt-list/blob/fde1a5ac1b7e8a45ff4255ee275ee77c7fe7e256/inter61d/CMOS.LST#L295">offset
0xf</a>.</p>
<pre><code>CMOS 0Fh - IBM - RESET CODE (IBM PS/2 &quot;Shutdown Status Byte&quot;)

(Table C0006)
Values for Reset Code / Shutdown Status Byte:
 00h-03h perform power-on reset
   00h  software reset or unexpected reset
   01h  reset after memory size check in real/virtual mode
    (or: chip set initialization for real mode reentry)
   02h  reset after successful memory test in real/virtual mode
   03h  reset after failed memory test in real/virtual mode
 04h    INT 19h reboot
 05h    flush keyboard (issue EOI) and jump via 40h:0067h
 06h    reset (after successful test in virtual mode)
    (or: jump via 40h:0067h without EOI)
 07h    reset (after failed test in virtual mode)
 08h    used by POST during protected-mode RAM test (return to POST)
 09h    used for INT 15/87h (block move) support
 0Ah    resume execution by jump via 40h:0067h
 0Bh    resume execution via IRET via 40h:0067h
 0Ch    resume execution via RETF via 40h:0067h
 0Dh-FFh perform power-on reset</code></pre>
<p>If the coreboot detects a warm reset, the rest of the system is
already initialized and we can jump directly to the SeaBIOS. If not, we
need to go through all inicialization stages <a
href="https://doc.coreboot.org/getting_started/architecture.html">described
in the coreboot documentation</a>.</p>
<p>These stages are too redundant for the use on a 486 system with 128kB
flash chips. It seems each stage needs a separate implementation of
functions used inside (e.g. multiple formatted print implementations).
It should be possible to merge some stages to save the precious space in
the chip.</p>
<h2 id="bootblock">Bootblock</h2>
<p>We start in <code>bootblock</code> stage which entire task is to
switch into a 32-bit protected mode and to initialize at least some
memory to store variables and stack for the C code. The original Award
BIOS does a similar thing from the address 0x1e000:</p>
<pre><code>Award BootBlock Bios v1.0</code></pre>
<p>Award BIOS has a failsafe flasher which will reflash the payload if
it detects an invalid payload image. The coreboot doesn’t support such a
mechanism - nobody today has the floppy on a system with Core 2 duo nor
Ryzen processors. However there is a mechanism in the coreboot to switch
between different implementations of subsequent stages, using it in 486
would took too much image space.</p>
<p>The bootblock should be as small as possible, at the start there is
not yet RAM enabled. This means the code cannot be compressed, it cannot
use variables nor stack. I tried to disassemble the Award BIOS and it
seems that even it didn’t have RAM for stack, the authors faked the
stack pointer to a read-only value. When a function is called the return
will use the return address at this fake stack.</p>
<p>(notice the AT&amp;T syntax)</p>
<pre class="assembly"><code>    mov     $fake_stack, %sp
    call    function

fake_stack:
    dw      return_address

return_address:
    nop</code></pre>
<p>This helps to call functions, but you still cannot use variables. The
“stack” is still readonly.</p>
<p>Coreboot skips all these stack faking procedures and instead it uses
so called Cache-as-RAM immediatelly after switching into the protected
(flat) mode. This allows us to use the stack immediatelly. The original
Award BIOS probably does this later too (so it can detect the RAM).</p>
<p>Cache-as-RAM uses a disabled L1 cache of the CPU to store the
variables and the stack. It is not actually possible to fully disable
the L1 data cache in 486. We can only disable the synchronization
mechanism - the write to the memory outside and we can disable the load
of the new cachelines (read miss). If the L1 cache wasn’t invalidated
after being disabled it will still access its records if the address is
hit.</p>
<p>The init code for cache-as-RAM is defined separately for each CPU
generation, but we can use <a
href="https://elixir.bootlin.com/coreboot/24.05/source/src/cpu/intel/car/p3/cache_as_ram.S#L87">Pentium
III code</a> for the inspiration.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    post_code<span class="op">(</span>POSTCODE_SOC_ENABLE_MTRRS<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Enable MTRR. */</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    movl    $MTRR_DEF_TYPE_MSR<span class="op">,</span> <span class="op">%</span>ecx</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    rdmsr</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    orl $MTRR_DEF_TYPE_EN<span class="op">,</span> <span class="op">%</span>eax</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    wrmsr</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    post_code<span class="op">(</span>POSTCODE_SOC_ENABLE_CACHE<span class="op">)</span></span></code></pre></div>
<p>We just need to skip the configuration of modern MTRR cacheable
regions, there is no MTRR support in 486 systems (excluding some Cyrix
CPUs). Instead 486 chipsets seems to enable cacheable regions
differently per chipset design. The UMC chipset seems to require to
enable the RAM to any caching. The clever idea is to set the maximum
possible RAM so the possible cacheable region is the largest.</p>
<p>We need to enable L1 cache first and flush it (so there is empty
space). Then we need to create a virtual array
(<code>car_mtrr_start</code>), which will contain CaR variables and
stack. When we read the addresses the L1 cache will fill with this
region (L1 miss). Also we can to erase the region by writting zeroes.
Right after this load the L1 cache is disabled, but any access to the
array region will cause L1 cache hit.</p>
<p>This is where the incompatibility with 486 starts. As stated before
the MTRR is used since i686 with some early implementations on cyrix
systems (according to the <a
href="https://github.com/cirosantilli/ralf-brown-interrupt-list/blob/fde1a5ac1b7e8a45ff4255ee275ee77c7fe7e256/inter61d/PORTS.A#L350">Ralf
Brown’s database</a>). MTRR defines ranges which can or cannot be
cached. Not having a standard mechanism will usually mean every
manufacturer will have a different aproach. Usually only addresses of
the RAM space will cause the chipset to allow CPU to fill the L1 cache
(via <code>/KEN</code> pin). Also some areas where ISA ROMs are located
aren’t cached unless specifically configured for (ROM shadow). And
finally if the CaR is located at the wrong address it may cause data
corruption later (this has bit me in the ass when I was doing RAM
detection). Any data table which are generated by coreboot could also be
corrupted by CaR.</p>
<p>The best solution for UMV is to probably set a configuration for the
maximum RAM size, then we will have a lots of addresses to choose the
CaR array from. The L1 cache on 486 CPUs is usually 8 or 16 kiB, which
is just enough to have a stack and some variables. Not fitted RAM slot
doesn’t really matter, all accesses should stay in CPU L1 cache anyway.
We could disable RAM completely, but it will be reconfigured soon
anyway. (NOTICE not sure if disabled RAM doesn’t affect L1 cache in some
way)</p>
<p>A funny fact: according to the datasheets some chipsets’ inital state
of the configuration after the power-on is a single RAM bank with the
smallest size. On FinALI you could theoretically use RAM right after
power on without any settings.</p>
<p>After CaR initialization the code jumps to C source and we can use a
libc-like functions (printf, memcpy …). If there is no other code
(northbridge, southbridge or superIO initialization) the coreboot will
search for the next stage “romstage” and jumps in to it.</p>
<h2 id="romstage">Romstage</h2>
<p>Coreboot allows this stage to be located anywhere, however we still
don’t have RAM so it still needs to be executed from ROM. FinALI chipset
has a poor design choice where 0xfffe0000 segment/area seems to be
unimplemented and the flash data are only accessible at 0xe0000. For
this special case we need to change the romstage location to 0xe0000.
Not sure wherever this needs to be changed, but one is probably <a
href="https://elixir.bootlin.com/coreboot/4.20/source/src/arch/x86/mmap_boot.c#L8">here</a>.</p>
<p>The second poor choice of the FinALI chipset is the fact how the
segments 0xe0000 and 0xf0000 are accessed. If there is a code running at
segment 0xe0000 or the segment is overwritten in the RAM shadow we
cannot use this address to read the original data from the flash chip.
There is a configuration bit in the chipset, which will effectivelly
invert the highest ROM address bit. This will effectively swap the both
segments. The segment 0xe0000 will be accessible at 0xffff0000 address.
It will also swap the original 0xf0000 segment to the segment 0xe0000,
so if a code depends on 0xf0000 and the 0xe0000 is rerouted into the RAM
(shadow), then the code will fail.</p>
<p>The bit can also stay swapped during the CPU reset so the CPU will
effectively try to access 0xefff0 of the flash chip. In a fully
implemented support the reset vector code needs to be duplicated and the
direct access to the flash needs to be limited as much as possible (make
a shadow copy right after DRAM init).</p>
<p>If the romstage was re-located to 0xe0000 address the coreboot will
try to blindly copy the data over itself, so there can also be a
condition to not copy if source and target are the “same” ROM region for
the FinALI chipset.</p>
<p>The source of romstage is written in C and we have the CaR memory
from the start. The task of the romstage is to initialize the rest of
the chipset and detect the L2 cache and RAM current configuration.
Unlike modern chipsets which can set a lot of registers for the PCIe
root hub, train DMI connection to the southbridge, access SPD EEPROM of
DIMM modules from the southbridge controller, the 486 is so simple the
romstage could be joined with the bootblock. This would save a lot of
code redundancy and aforementioned FinALI poor design choices. Only
problem would be the bootblock will be large and it will not fit the
lockable region of the most flash chips.</p>
<h2 id="dram">DRAM</h2>
<p>Next thing we do is the DRAM detection. We need to implement a
different method unlike the vanilla coreboot is using. The vanilla
supports only SDRAM (and later) and the “detection” just loads the SPD
EEPROM and calculates the timing and size. For an asynchronous DRAM we
need to write our own detection mechanism.</p>
<p><a
href="https://theretroweb.com/chip/documentation/m1487-m1489-486-pci-chip-set-199707-644fcb7938fcc190749081.pdf">The
FinALI datasheet</a> specifies on page 119 an algorithm for writing a
value to one address and checking if the value is visible at another
address, which has inverted a single address pin. Basicaly if the
address pin is not connected on the DRAM chip (e.g. because the chip is
smaller), we will see the same value “aliasing” on the both addresses.
This algorithm is simple, but it needs to be generalized if we want to
support more than one chipset (each chipset has a different pin to
address map).</p>
<p>The address bus of DRAM is multiplexed between rows and columns.
Different DRAM chips can have a different geometry (different number of
rows and columns). The best solution is to just detect the number of
rows and columns. FinALI algorithm seems to have the rest of address
bits as don’t care (they only needs to be the same), but having a
different addresses would make the algorithm more complex. Instead we
use a single bit being set to <code>1</code>, while the rest are set to
<code>0</code>. This means the algorithm will always check the address
<code>1 &lt;&lt; N</code> and <code>0</code>. Then the one-shot bit can
directly refer to a column/row pin of the DRAM.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">const</span> u8 columns_to_address<span class="op">[</span><span class="dv">12</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">13</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">const</span> u8 rows_to_address<span class="op">[</span><span class="dv">12</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">14</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">17</span><span class="op">,</span> <span class="dv">18</span><span class="op">,</span> <span class="dv">19</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">21</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">23</span><span class="op">,</span> <span class="dv">24</span><span class="op">,</span> <span class="dv">25</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>As we can see in the <a
href="https://theretroweb.com/chipsets/174#docs">FinALI datasheet</a> on
the page 107:</p>
<figure>
<img src="./images/dram_address_bits.png" title="DRAM address mapping"
alt="DRAM address mapping" />
<figcaption aria-hidden="true">DRAM address mapping</figcaption>
</figure>
<p>There is a different address mapping/DRAM geometry for the each
memory type. Instead if we always set the largest geometry (16M - 4kx4k)
we will always get the valid address for an implemented column/row pin
and the data alias for an unimplemented column/row pin. The computed
columns/rows number can then be used to get the DRAM chip geometry from
a predefined/chipset specific mapping table.</p>
<p>The algorithm is repeated for each DRAM bank while the rest of the
banks are disabled. Also L2 cache is still disabled and the L1 must be
still in the CaR mode (reconfiguring the banks and poking addresses is
destructive). Also the CaR area needs to be on the different addresses
than the tested address pattern (CaR array cannot contain addresses with
a single “1” bit). However both locations can be changed if some chipset
would be incompatible with them.</p>
<p>There was also an observed situation when no DRAM was connected and
the value was stuck on the bus capacitance. This can be fixed by
inserting a dummy write cycle outside the testing addresses (and CaR
area) so the bus capacitance will be reseted.</p>
<h3 id="l2-cache">L2 cache</h3>
<p>The same one-shot algorithm can be used to detect the size of the L2
cache. The L2 cache must be forced to always hit all address are
accessed and it needs to be set to the highest size with the dual bank
configuration. Some chipsets need to have DRAM enabled too that the
cache cycle is generated at all (no MTRR ;-) ). The always hit mode is
usually a special settings of the chipset and can be used only in
romstage.</p>
<p>First we check if address 0 is accessible. This decides if any L2
cache is installed. Then we need to check the address 4 (or any
divisible by 4) which will be readable only if the cache is dual
banked/interleaved. If not then we need to set the cache to be single
banked.</p>
<p>The detection of L2 size is practically the same as for DRAM. Check
the two neighboring dwords if the L2 cache is double banked (set the
correct number of banks) and then just set one-hot address from the
smallest to the largest expected L2 size and the first iteration which
does alias is also the L2 cache size.</p>
<p>Finally we need to make the L2 cache coherent, so we disable L2
forced hit, set the correct timing and set the dirty/tag bits mode. Next
we have to fill the cache lines right before we disable CaR mode.</p>
<p>This wasn’t tested yet but it may be neccessary to enable ROM shadow
regions at this place.</p>
<h3 id="rom-shadow">ROM shadow</h3>
<p>Historicaly the area between addresses 0xc0000-0xfffff contained
option ROMs, video ROM or BIOS. However if there wasn’t any option
installed the precious memory space was unused. The RAM also wasted the
same addresses forever hidden. This probably led to an ability to
disable the ROM chip select signals and rerouting the address space to
the RAM. Technically you can have a general RAM area here but
realistically only data and code from option ROMs or BIOS can be
shadowed here. Accessing the RAM is faster than accessing the ROM.</p>
<p>Chipset usually supports a locking of the entire region. Locked
region will be read-only simulating the original ROM space. This limits
having there a general RAM for running programs. Locking is also in a
way of “everything or nothing”. The shadowing ability is actually pretty
useful if you want to copy a ROM image from a PCI card to have the code
available even for 16bit MSDOS.</p>
<p>Some chipsets can also choose if the ROM access goes to ISA bus or to
the actual BIOS ROM chip.</p>
<p>An improvement of this ROM shadow is to allow the chipset to cache
the area.</p>
<p>This all results in a few possible modes:</p>
<ul>
<li>Access to ISA bus</li>
<li>Access to ROM chip</li>
<li>Access the copy in RAM</li>
<li>Access the copy in cache</li>
</ul>
<p>Later the SeaBIOS searches for an option ROM, so it needs to know how
to unlock any assigned segment to write the copy. It will also needs to
lock it before the booting.</p>
<p>The locking function must be implemented for each chipset, the
general call <code>make_bios_writable()</code> is located in
<code>shadow.c</code> of the SeaBIOS source code tree. The unlock
function is called <code>make_bios_readonly()</code>.</p>
<h2 id="postcar-stage">Postcar stage</h2>
<p>Finally the CaR is not needed so we can dismantle it and enable the
L2 cache. This stage is decompressed and then started from the RAM.
Another function of the postcar stage is to prepare tables and variables
for the RAM and to decompress and load the next stage: “ramstage”. We
can see how the CaR disabling is implemented in the vanilla coreboot <a
href="https://elixir.bootlin.com/coreboot/24.05/source/src/arch/x86/exit_car.S#L52">here</a>.</p>
<pre class="assembly"><code>chipset_teardown_car:
    pop %esp

    post_code(POSTCODE_POSTCAR_DISABLE_CACHE)

    /* Disable cache. */
    movl    %cr0, %eax
    orl $CR0_CacheDisable, %eax
    movl    %eax, %cr0

    post_code(POSTCODE_POSTCAR_DISABLE_DEF_MTRR)

    /* Disable MTRR. */
    movl    $MTRR_DEF_TYPE_MSR, %ecx
    rdmsr
    andl    $(~MTRR_DEF_TYPE_EN), %eax
    wrmsr

    /* Disable the no eviction run state */
    movl    $NoEvictMod_MSR, %ecx
    rdmsr
    andl    $~2, %eax
    wrmsr
    andl    $~1, %eax
    wrmsr

    post_code(POSTCODE_POSTCAR_TEARDOWN_DONE)

    /* Return to caller. */
    jmp *%esp</code></pre>
<p>As the L2 cache on 486 is different it is not completely clear where
we should put L2 fill/init code. By running some experiments this code
works:</p>
<pre class="assembly"><code>    /* fill L2 cache, twice as size? */
    movl    $0x200000, %edi
    movl    $0x300000, %ecx
    sub     %edi, %ecx
    shr     $2, %ecx
    cld
    xor     %eax, %eax
    rep     stosl   /* DF=0, up */

    invd

    /* Enable caching if not already enabled. */
    mov     %cr0, %eax
    and     $(~(CR0_CD | CR0_NW)), %eax
    mov     %eax, %cr0

    /* Ensure cache is clean. */
    invd

    movl    $0x200000, %edi
    movl    $0x400000, %ecx
    sub     %edi, %ecx
    shr     $2, %ecx
    cld
    rep     lodsl   /* DF=0, up */</code></pre>
<p>Enabled L2 cache needs to hit every address which is erased. Next the
L1 cache is invalidated (and data are lost), but this according to the
Intel 486 datasheet may cause L2 cache flush. Then the L1 cache is
enabled, invalidated again and then an arbitrary range of RAM is read
(2x size of L2 cache is recommended).</p>
<p>This code is most likely highly inefficient and redundant, but it
worked on the testing board ;-). If the L2 cache is not filled, the
power-on values in its SRAM chips can contain incorrect informations
which will (at L2 hit) be returned to the CPU (and the code will
crash).</p>
<p>Now we shouldn’t touch any cache settings or the cache will become
non-coherent with RAM again. Also as we will now run from RAM L2 cache
could contain the code we are running and any noncoherency could crash
the code in most unexpected places.</p>
<p>Postcar will then find and decompress ramstage payload and thats
it.</p>
<p>NOTICE: It is possible postcar stage could be merged to bootblock and
ramstage. So we could save more space in the bios image.</p>
<h2 id="ramstage">Ramstage</h2>
<p>Finaly we are getting to the actual coreboot code. Ramstage is packed
with an LZMA compression (sometimes even 50% of the original size). It
will enumerate PCI bus including PCI-PCI bridges ;-), define memory
ranges for BIOS e820 API (it will also use them for PCI bus
enumeration). SMBIOS, PIRQ and ACPI tables can be generated too.
Original coreboot supports even initial video, but we will not use it
(as the code eats too much space).</p>
<p>Ramstage can do an initialization of some peripherals
(e.g. integrated IDE, superIO). Its final operations is to load a
payload, which is in our case a SeaBIOS. SeaBIOS is decompressed into
segments E and F in the RAM shadow. After loading the payload ramstage
will do some final chipset settings including locking the RAM shadow
from writing and jumps to the payload.</p>
<h2 id="payloadseabios">Payload/SeaBIOS</h2>
<p>From now on the SeaBIOS code is excuted. Its code in E/F segments
should emulate IBM PC compatible BIOS. Coreboot payload loader system
jumps to an inner function, but the SeaBIOS has a legacy reset vector
code too (F000:FFF0 of 8086). We can jump to this address if we detect a
warm reset from 386+ reset vector (0xFFFFFFF0) and SeaBIOS will just
continue and handle warm reset.</p>
<p>The SeaBIOS is built automaticaly, but with a predefined
configuration. We can change it in the mainboard directory in the
coreboot tree <code>src/mainboard/*/*/config_seabios</code>.</p>
<p>We need to patch SeaBIOS code too, careful any
<code>make clean</code> will reset any changes as it redo a git
checkout. I’ve disabled the checkout call located <a
href="https://elixir.bootlin.com/coreboot/4.19/source/payloads/external/SeaBIOS/Makefile#L37">here</a>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode makefile"><code class="sourceCode makefile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dv">checkout:</span><span class="dt"> fetch</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>echo <span class="st">&quot;    Checking out SeaBIOS revision </span><span class="ch">$(</span><span class="dt">TAG-y</span><span class="ch">)</span><span class="st">&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    cd seabios; git checkout master; git branch -D coreboot 2&gt;/dev/null; git checkout -b coreboot <span class="ch">$(</span><span class="dt">TAG-y</span><span class="ch">)</span></span></code></pre></div>
<p>If we want to use floppy, SeaBIOS supports that, but only for QEMU.
We can force the code for any hardware by making <a
href="https://github.com/coreboot/seabios/blob/ec0bc256ae0ea08a32d3e854e329cfbc141f07ad/src/hw/floppy.c#L158">this
condition</a> be always true:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CONFIG_QEMU<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        u8 type <span class="op">=</span> rtc_read<span class="op">(</span>CMOS_FLOPPY_DRIVE_TYPE<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>type <span class="op">&amp;</span> <span class="bn">0xf0</span><span class="op">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>            addFloppy<span class="op">(</span><span class="dv">0</span><span class="op">,</span> type <span class="op">&gt;&gt;</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>type <span class="op">&amp;</span> <span class="bn">0x0f</span><span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            addFloppy<span class="op">(</span><span class="dv">1</span><span class="op">,</span> type <span class="op">&amp;</span> <span class="bn">0x0f</span><span class="op">);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span></code></pre></div>
<p>Adding this functionality into the normal SeaBIOS use case was
discussed a few times, but the result is “don’t want to add legacy
functionality”</p>
<p><a
href="https://mail.coreboot.org/hyperkitty/list/seabios@seabios.org/thread/FH4WNWM63C2FFGKFXBSJM43AJ5EAM6CL/#FH4WNWM63C2FFGKFXBSJM43AJ5EAM6CL">Support
CMOS setting outside QEMU</a></p>
<p><a
href="https://mail.coreboot.org/hyperkitty/list/seabios@seabios.org/thread/TCM5FSZ3KHHI5FTRQ2CBDQKSD2U27KZU/#B3YVXN4Z6VKM3K4D36MWFAFD62HYEX45">Floppy
drive configuration</a></p>
<p>Also configuring the PIT counter 1 is critical. Parts of MSDOS will
freeze if it receives the machine without initialized PIT. SeaBIOS <a
href="https://github.com/coreboot/seabios/blob/ec0bc256ae0ea08a32d3e854e329cfbc141f07ad/src/hw/timer.c#L274">didn’t
do the configuration</a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>pit_setup<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>CONFIG_HARDWARE_IRQ<span class="op">)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// timer0: binary count, 16bit count, mode 2</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    outb<span class="op">(</span>PM_SEL_TIMER0<span class="op">|</span>PM_ACCESS_WORD<span class="op">|</span>PM_MODE2<span class="op">|</span>PM_CNT_BINARY<span class="op">,</span> PORT_PIT_MODE<span class="op">);</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// maximum count of 0000H = 18.2Hz</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    outb<span class="op">(</span><span class="bn">0x0</span><span class="op">,</span> PORT_PIT_COUNTER0<span class="op">);</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    outb<span class="op">(</span><span class="bn">0x0</span><span class="op">,</span> PORT_PIT_COUNTER0<span class="op">);</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><a
href="https://github.com/coreboot/seabios/blob/ec0bc256ae0ea08a32d3e854e329cfbc141f07ad/src/optionroms.c#L266">This
condition</a> expects the PCI space cannot be mapped in the first 16 MiB
of the address space of the CPU.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="st">-    if (orig == sz || (u32)(orig + 4*1024*1024) &lt; 20*1024*1024) {</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="va">+    if ((orig == sz) || ((u32) orig &lt; 4*1024*1024)) {</span></span></code></pre></div>
<p>It is probably a good constraint so ISA space (DMA …) doesn’t collide
with the PCI space. For now we can disable this requirement. Some 486
chipsets supports PCI space right after the end of RAM. If there is less
than 16 MiB of RAM the test will fail. The support to enumerate the PCI
addresses at the SeaBIOS compatible posibition is not yet implemented in
the coreboot. BTW a 486 machine can easily have 4 MiB of RAM.</p>
<p>The important feature to add is the ability to control ROM shadow
read-only function. SeaBIOS can fill option ROM regions with data from
PCI option ROMs and it need to be able to write there. The set of the
calls are <a
href="https://github.com/coreboot/seabios/blob/ec0bc256ae0ea08a32d3e854e329cfbc141f07ad/src/fw/shadow.c#L116">defined
here</a>:</p>
<p>And we need to correctly set the configuration bits in the chipset.
Other chipset routines can be completelly erased to save the space (or
you can use some detection routines). There is no compile time
definition support :-(.</p>
<p>Rest of the patches are not so important to describe here, they are
part of the git repo.</p>
<p>We can set any supported hardware we will want to use in the
configuration settings. However some drivers may use too much space.
Some chipsets don’t work with PS/2 mouse support and PS/2 mouse being
disconnected. Debug asserts cause a freeze with some 32-bit
applications. CDROM/DVD works, but it takes a really long time to detect
a new medium.</p>
<h2 id="umc-addendum">UMC addendum</h2>
<p>Even though the original coreboot patch was made for FinALI chipset,
the most work was done for UMC 8881/6 chipset. Doing so was a really
“fun”/“frustrating” activity (chose one :-D) as there isn’t any
datasheet. Still I’ve bought a board, which turned to be faulty. The
rise times on the ISA bus (including the ROM chip) were out of spec
because the southbridge was most likely damaged (there is a damaged pin
on the ISA bus near the 12V line).</p>
<figure>
<img src="./images/rise_time.jpg" title="ISA rise times"
alt="ISA rise times" />
<figcaption aria-hidden="true">ISA rise times</figcaption>
</figure>
<p>To gain at least some use from the broken board I decided to
recreated a technical manual by reverse engineering the chipset. Thanks
to people at vogons and retroweb I was able to put together pinout and
registers of the chipset. Hacking the real hardware on a replacement
board allowed me to correct some of these descriptions and model the
hardware behaviour. The most important was a map between DRAM
columns/rows and memory address. However there is still a lot of unknown
registers. The system can boot with preset value obtained from the
values set by vanilla BIOS though.</p>
<h2 id="getting-the-compiler">Getting the compiler</h2>
<p>To build anything for 486 system we need a compiler. Modern 64-bit
distributions doesn’t support a compilation to 32-bit output anymore.
Even if they did, some crt libraries (e.g. divide functions) are alread
pre-compiled with too modern opcodes. This took me so long to find out
that an OS bundled compiler still generates executable files with
<code>endbr32</code> instruction even if <code>-march=i486</code> flag
is set. Running <code>endbr32</code> instruction on a 486 causes an
illegal instruction exception. (I didn’t even know the instruction
before the meltdown/spectre affair appeared).</p>
<p>We can kill two birds with one stone if we use the <a
href="https://buildroot.org/download.html">buildroot project</a> or the
<a href="https://github.com/pc2005cz/buildroot_486">custom 486
branch</a> which has already included <a
href="https://github.com/pc2005cz/TheUltimate486Upgrade/tree/main/resources/buildroot.patch">some
486 patches</a>.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> where_git_repositories_are_located</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/pc2005cz/buildroot_486.git</span></code></pre></div>
<p>We can add a pre-generated <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/.config_buildroot">buildroot
.config file</a> for the 486 systems or we can enable only a smaller set
of packages so the cross-compiler is generated faster. The set of the
enabled options can be usually changed later (some packages’ builds
needs to be cleaned/rebuilt first sometimes).</p>
<p>Buildroot packages will be described later.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> menuconfig</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span></code></pre></div>
<p>Buildroot will then build a compiler, all standard linux usespace
application and it will pack it into a tar archive, which we can unpack
directly to the hard drive. It could also build a kernel, but this would
made the modifications more difficult to maintain. It is better to
compile the kernel as a standalone project.</p>
<p>Also don’t be alarmed if the build fails. It does often, you gonna
need to investigate and fix which package did it though. Some packages
make fail just when downloading the source tarball. The hosting servery
is usually under maintenance. It suck, but the tarballs can be copied
from a mirror and once a tarball is downloaded it won’t be re-downloaded
again for any subsequent recompilations.</p>
<p>If we define the path to the compiler executables we can use it to
compile any external software. The compiler is integrated to the system
libraries of the target distribution so it has most of the dependencies
correctly set. The rest can be fixed with a <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/envir_buildroot_486.sh">build
evinronment script</a> which sets the building environment to buildroot
compiler. Don’t forget to set the correct path <code>BROOT_PATH</code>
for the buildroot location.</p>
<h2 id="building-the-coreboot">Building the coreboot</h2>
<p>After an optional use of the <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/.config_coreboot">default
coreboot configuration for Biostar MB-8433UUD</a> we can just run these
commands:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span> /path_to/envir_buildroot_486.sh</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> menuconfig</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span></code></pre></div>
<p>If the build doesn’t fail we have now a flash image in
<code>./build/coreboot.rom</code>. All we need now is to flash the image
into a chip and boot from it. We can use a programmer or just do a
hotflash. I’ve tried to make a programmer with XC9572 CPLD which had too
much problems with noise and with different I/O voltages which taught me
a valuable lesson: the best solution to a problem is usually the easiest
one: I “modded” the flash chip itself with a duct tape for an easier
hotflash :-D.</p>
<figure>
<img src="./images/hotflash.jpg" title="Medium-removal-force socket"
alt="Medium removal force socket" />
<figcaption aria-hidden="true">Medium removal force socket</figcaption>
</figure>
<p>Surprisingly it works really well. The tape spreads out the pull-out
force and makes the chip more accessible.</p>
<p>An updated board can be connected via null modem cable (COM1 set to
115200 bauds by default). The power-on register values on the most super
IO chips have the COM1 port usually enabled. If not the coreboot needs
to enable them earlier.</p>
<p>If there is some messages shown on the COM terminal, the coreboot at
least tries to do something and after some time we should ideally see a
boot menu on the monitor where we can select any supported boot
device.</p>
<p>NOTICE: There is no CMOS setup, all values in CMOS are ignored and
don’t touched. There isn’t actually a good SETUP-like application for
coreboot. The nvramcui exists, but it needs API library code which is
too big to fit 128 kB image. The best solution would be to write a SETUP
which uses BIOS API to e.g. print on the screen.</p>
<h1 id="preparing-the-drive-image">Preparing the drive image</h1>
<p>If we use a small enough drive, we could use the same image under
vanilla BIOS and under coreboot. A 4GB SD or CF card should work well if
the sector addressing is set to LBA. The drive will also need to have a
bootloader. Ideally one which can boot multiple OSes.</p>
<figure>
<img src="./images/pata_cf.jpg" title="PATA CF adapter"
alt="PATA CF adapter" />
<figcaption aria-hidden="true">PATA CF adapter</figcaption>
</figure>
<p>With coreboot int 0x13 implementeation you can try to use IDE/SATA
adapter. However it seems some of my 486 doesn’t like them. They will
identify the drive with errors in the name and then the drive access
will freeze. Not sure why but my hypothesis is either an incompatible
timing of the adapter or different voltage levels. Pre-pentium boards
have the IDE signals connected via TTL 74F245 buffers and the adapter
may expect CMOS drivers which are expected on modern chipsets.</p>
<h2 id="bootloader">Bootloader</h2>
<p>For some reason GRUB bootloader always crashed and rebooted when I
tried to boot the system. LILO is too old and too its configuration
update is too complicated if LILO is also used on the main computer.
Therefore the best bootloader to use is SYSLINUX. It can have a simple
text mode menu and it can boot multiple images including also MSDOS.</p>
<p>HDD should contain a small MSDOS partition with SYSLINUX files
(including vmlinuz and System.map), <a
href="https://www.philscomputerlab.com/dos-benchmark-pack.html">DOS
Benchmark Pack</a> and ideally a flasher. I used uniflash for entire
coreboot development.</p>
<p>Also we should be able to create the same image for generic/multiple
drives if we want to try different interfaces and adapters. For this
purpose I’ve made a <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/rootfs_builder_dangerous.sh">bash
script</a>, which generates a disk image and writes it on a specified
drive.</p>
<p>A variable DRIVE needs to be set to your (removable) drive, careful
if you make a mistake it will erase your main drive, also you need to
run script with the root privileges.</p>
<p>This will erase an MBR of a drive, so kernel won’t get confused.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dd</span> if=/dev/zero bs=512 count=1 oseek=0 conv=notrunc of=<span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">&quot;</span></span></code></pre></div>
<p>And we partition the drive to have roughly 750MB of FAT16 and the
rest is ext4 for linux.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span> <span class="kw">|</span> <span class="ex">parted</span> <span class="at">-a</span> none <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="st">mklabel msdos</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="st">unit s</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="st">mkpart primary 63s 1527679s</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="st">type 1 6</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="st">mkpart primary ext4 1527680s -1s</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="st">set 1 boot on</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="st">quit</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="op">EOF</span></span></code></pre></div>
<p>We write syslinux MBR from its installed location to the drive.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dd</span> if=/usr/share/syslinux/mbr.bin conv=notrunc of=<span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">&quot;</span></span></code></pre></div>
<p>It doesn’t fill entire MBR, partitions are not overwritten.</p>
<p>Now we patch the CHS address of the first sector of partition. It
seems that was the only obstacle to make the linux created partitions to
work on 486 Award BIOSes.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="at">-e</span> <span class="at">-n</span> <span class="st">&quot;\x01\x01\x00&quot;</span> <span class="kw">|</span> <span class="fu">dd</span> bs=1 count=3 oseek=<span class="va">$((</span><span class="bn">0x1bf</span><span class="va">))</span> conv=notrunc of=<span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">&quot;</span></span></code></pre></div>
<p>Careful, the changed partition table worked with vanilla 486 Award,
but the image may fail on more modern architecture (I tried to boot the
DOS on an AthlonXP board and the LBA/CHS autodetection failed).</p>
<p>Now we can format partitions to the required filesystems.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">mkdosfs</span> <span class="at">-v</span> <span class="at">-F</span> 16 <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">1&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">mkfs.ext4</span> <span class="at">-q</span> <span class="at">-F</span> <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">2&quot;</span></span></code></pre></div>
<p>Now the funny part. You can actually make a bootable MSDOS 6.22 drive
by just copying the files over. However there is a catch. The system
files need to be copied with the correct order: IO.SYS as the first ever
written file (first entry in root directory) and MSDOS.SYS as the second
written file. The rest of files can be copied with any order.</p>
<p>So we prepare the MSDOS files (or the entire filesystem) into local
subdirectory, mount the partition and copy the files into it.</p>
<p>MSDOS partition gets mounted into <code>1</code> subdirectory:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> ./1</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mount</span> <span class="at">-o</span> noexec,fmask=111 <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">1&quot;</span> ./1</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> ./files/IO.SYS ./1/      <span class="co">#NOTICE must be first thing copied</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> ./files/MSDOS.SYS ./1/   <span class="co">#NOTICE must be second thing copied</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> ./files/COMMAND.COM ./1/</span></code></pre></div>
<p>The SYSLINUX should be installed into <code>boot</code> subdirectory
with modules in <code>boot/bin</code> so let’s create them:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> ./1/boot/bin</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/cpuid.c32 ./1/boot/bin</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/menu.c32 ./1/boot/bin</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/sysdump.c32 ./1/boot/bin</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/reboot.c32 ./1/boot/bin</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/pcitest.c32 ./1/boot/bin</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/meminfo.c32 ./1/boot/bin</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/linux.c32 ./1/boot/bin</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/isolinux.bin ./1/boot/bin</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/cmd.c32 ./1/boot/bin</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /usr/share/syslinux/config.c32 ./1/boot/bin</span></code></pre></div>
<p>Not every module is required, some are used for testing, but you’ll
definitelly need <code>linux.c32</code> ;-).</p>
<p>The configuration file <code>syslinux.cfg</code> should be located in
<code>boot</code> too and it’s content should look like this:</p>
<pre><code>default /boot/bin/menu.c32
prompt 0
TIMEOUT 25

MENU TITLE 486 chipsets testing

label umc
  MENU LABEL Linux UMC
  LINUX /boot/vmlinuz
  append libata.dma=0 console=ttyS0,115200,8n1 module.blacklist=pata_isapnp module_blacklist=pata_isapnp,pata-isapnp libata.force=3:pio0 initcall_blacklist=pata_isapnp,pata-isapnp root=/dev/sda2 pci=rom,assign-busses,nommconf,routeirq,biosirq,irqmask=0xffff,noacpi,pcie_scan_all,realloc,nomsi,noaer,noari,conf1 raid=noautodetect fbcon=map:0 memory_corruption_check=0

label dos
  MENU DEFAULT
  MENU LABEL DOS bench
  kernel /boot/fat16_v5.bss</code></pre>
<p>The format is pretty simple, just a definition of two bootable
configurations their names and parameters for linux boot, where we
disable modern stuff.</p>
<p>For booting MSDOS we will need to get a standard MSDOS bootsector. It
should be possible to just copy the first 512 bytes of any FAT16 image
and save it into <code>/boot/fat16_v5.bss</code>. When selected as the
option the SYSLINUX will just load the bootsector a execute it.</p>
<p>As we want to make things quick, we can just make a copy of
everything we need to put on the partition and put it in
<code>files</code> subdirectory. After that we can (after special care
for IO.SYS and MSDOS.SYS) just use rsync:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rsync</span> <span class="at">-a</span> <span class="at">-H</span> <span class="at">-A</span> <span class="at">-X</span> <span class="at">--open-noatime</span> ./files/ ./1/</span></code></pre></div>
<p>As everything is copied now, we can unmount the partition:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">umount</span> <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">1&quot;</span></span></code></pre></div>
<p>And install the initial syslinux configuration:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">syslinux</span> <span class="at">-i</span> <span class="at">-d</span> boot <span class="st">&quot;</span><span class="va">${DRIVE}</span><span class="st">1&quot;</span></span></code></pre></div>
<p>It seems changing <code>syslinux.cfg</code> or updating
<code>vmlinuz</code> doesn’t require to reinstall it.</p>
<p>Copying any software on linux ext4 partition is a similar process
(mount, rsync, unmount).</p>
<p>The image should be now able to boot into MSDOS on Biostar MB-8433UUD
or ABit AB-PB4 board with the drive set to use LBA sector addressing
scheme.</p>
<h2 id="preparing-the-linux">Preparing the linux</h2>
<p>Caution: this will need a lots of space (30 GB of the free space is
<em>recomended</em>).</p>
<p>There isn’t any modern distribution to be 486 compatible, however the
kernel (as of 6.3.9) still supports the CPU. We gonna need to download
the kernel source:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> where_git_repositories_are_located</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/pc2005cz/linux_486.git</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> linux_486</span></code></pre></div>
<p>Having a local git repo is useful for modification of the source
codes. Also if the 486 support may be eventually removed, we will always
be able to checkout an older version.</p>
<p>The github repo has already all the patches included, but it is
always possible to use the vanilla-stable tree and apply the patches
selectively. The 486 support was branched from
00d3ac724541a0661b148b16cf34fac135a4fd53 (<a
href="https://github.com/gregkh/linux/tree/v6.3.9">Linux 6.3.9</a>) and
all patches are <a
href="https://github.com/pc2005cz/TheUltimate486Upgrade/tree/main/resources/kernel.patch">located
here</a>.</p>
<p>The config of the kernel can be used from <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/.config_kernel">here</a>
and the building script from <a
href="https://raw.githubusercontent.com/pc2005cz/TheUltimate486Upgrade/refs/heads/main/resources/mk_kernel_6.3.9_486">here</a>.
Don’t forget to change the paths in the build script. It expects
<code>./src_6.3.9_486</code> for the kernel source and it will create
<code>./build_6.3.9_486</code> for the object files. It is also
expecting to have the <code>.config</code> located there.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./mk_kernel_6.3.9_486</span></span></code></pre></div>
<p>If the kernel sucessfully compiles, there should be
<code>./build_6.3.9_486/_BUILD</code> subdirectory with finished
<code>vmlinuz</code>, <code>System.map</code> and a
<code>lib/modules</code> subdirectory with kernel drivers. If we copy
these files into our linux and msdos partitions the 486 should be able
to boot into the linux with an initial console on the first serial port
<code>/dev/ttyS0</code>.</p>
<p>Except with vanilla BIOS some PCI cards will not work. It turns out
kernel needs an IRQ routing table to get the correct INTx line for the
PCI device, but few old BIOSes don’t have the table implemented (maybe
getting the routing is possible somehow from PCI BIOS calls). Anyway we
can always go back to the kernel source and patch our own table in.
There is also a problem of setting the routing itself. It needs to write
configuration into the chipset registers and only some 486 chipsets are
supported. So if the vanilla BIOS doesn’t initialize a PCI card
correctly we need to have this support included anyway.</p>
<p>Of course using the coreboot makes the patching of the PIRQ table
into the kernel redundant as it generates PIRQ tables correctly.</p>
<h3 id="pirq-routing-table">PIRQ routing table</h3>
<p>As we can see from <a
href="https://en.wikipedia.org/wiki/Peripheral_Component_Interconnect#Connector_pinout">wikipedia</a>:</p>
<figure>
<img src="./images/pci_pinout.png" title="PCI INTx pins"
alt="PCI INTx pins" />
<figcaption aria-hidden="true">PCI INTx pins</figcaption>
</figure>
<p>every PCI slot supports 4 lines to receive interrupts from the card.
Usually a card has only a single interrupt source. However if the card
uses MSI or MSI-X there virtually unlimited count of interrupt sources.
No 486 supports that, but thanksfully 99% of PCI compatible devices can
still use legacy INTx interrupts nowadays.</p>
<p>A PCI device will most likely use its INTA pin to deliver an
interrupt to the CPU. If all PCI devices/slots used the same INTA pin,
the interrupt handler would get too overloaded in decision which device
was the source of the interrupt. So in a case where there is a multiple
of interrupt inputs, their connection is physically shifted for each PCI
slot. For example the first PCI slot will have interrupt line A (INTA)
connected to IRQ1 (and INTB -&gt; IRQ2, INTC -&gt; IRQ3 and INTD -&gt;
IRQ4) but the second PCI slot will have interrupt line A (INTA)
connected to IRQ4 (INTB -&gt; IRQ1, INTC -&gt; IRQ2 and INTD -&gt;
IRQ3).</p>
<p>The mapping for each slot will be different for each motherboard
model, so BIOS <a
href="https://www.coreboot.org/Creating_Valid_IRQ_Tables">must be aware
of this mapping table</a>. OS will then request the table and allocates
the interrupts for each PCI device. With a wrong mapping the PCI device
would generate an IRQ but there wouldn’t be any handler to service that
and the handler would wait on a different IRQ which would never
occured.</p>
<p>If we want to use the kernel with the old BIOS which doesn’t export
IRQ mapping table, we can always force the table if the autodetection
fails. For example at <a
href="https://elixir.free-electrons.com/linux/v6.3.9/source/arch/x86/pci/irq.c#L171">this
place</a>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    rt <span class="op">=</span> pirq_check_routing_table<span class="op">((</span>u8 <span class="op">*)</span>__va<span class="op">(</span>pirq_table_addr<span class="op">),</span> NULL<span class="op">);</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rt<span class="op">)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rt<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    printk<span class="op">(</span>KERN_WARNING <span class="st">&quot;PCI: PIRQ table NOT found at pirqaddr</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>I’ve patched the kernel with manually construed mapping for <a
href="https://theretroweb.com/motherboards/s/zida-4dps-3-x">Zida
4DPS</a>, <a
href="https://theretroweb.com/motherboards/s/abit-ab-pb4-rev-1.3">ABit
AB-PB4</a> and <a
href="https://theretroweb.com/motherboards/s/biostar-mb-8425uud-a">Biostar
MB-8433UUD</a>. Also I’ve made one for <a
href="https://theretroweb.com/motherboards/s/intel-classic-pci-ed-ninja">Intel
Classic/PCI ED (Ninja)</a>, but I had the board only borrowed for a few
days and I didn’t test it thoroughly.</p>
<p>The rebuilt kernel (<code>vmlinuz</code>, <code>System.map</code> and
modules) with injected mapping tables should be able to boot with an
early console appearing on the first serial port.</p>
<h2 id="playing-in-linux">Playing in linux</h2>
<p>Having linux working is a great addition to the BIOS debugging
ability. We have the entire system to be accessible and with abstraction
layers we can poke any controller just from the shell script.</p>
<h3 id="accessing-the-ram">Accessing the RAM</h3>
<p>If /dev/mem API is compiled into the kernel. We can use it to read
from any address. There are few program which uses it. In most
distributions we can find <a
href="https://github.com/pengutronix/memtool"><code>memtool</code></a>,
<a
href="https://busybox.net/downloads/BusyBox.html#devmem"><code>devmem</code></a>
or <a href="https://github.com/radii/devmem2"><code>devmem2</code></a>.
Also we can write our own application as <code>/dev/mem</code> is just a
special file and required address is an offset to seek into.</p>
<p>The syntax is usually along the lines with <code>address</code>
<code>word size</code> <code>written value</code>.</p>
<h3 id="accessing-io-ports">Accessing I/O ports</h3>
<p>Similary as <code>/dev/mem</code> there is an API for IO ports (on
x86) in the kernel too. I didn’t found a satisfying utility, so I wrote
<a href="https://github.com/pc2005cz/portyr">my own</a>. Mechanism is
basically the same (offset = port address). Alternativelly the tool can
directly use out/in instructions (it must be permitted with
<code>ioperm()</code> call though).</p>
<h3 id="accessing-pci-config-space">Accessing PCI config space</h3>
<p>We can use <code>/dev/port</code> to access PCI. Or we can use
<code>setpci</code>. The syntax need to identify the device
(<code>-s bus:device.function</code>), the optional type of accessign
method (<code>-A</code>) and the config register address with the word
size (<code>b</code>,<code>h</code>,<code>l</code>) and optionally the
new value.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">setpci</span> <span class="at">-A</span> intel-conf1 <span class="at">-s</span> 0:0x10.0 0x50.b=0x42</span></code></pre></div>
<p>The bus/device/function values for each device can be obtained with
<code>lspci</code> command. This is a very useful program as we can use
it to dump register space and <em>borrow</em> the UMC chipset
configuration settings from the vanilla BIOS.</p>
<h2 id="speed-up">Speed up</h2>
<p>The integrated IDE of UMC PCI chipset is really slow. It seems to be
connected via 74F245 buffer directly from the ISA bus. The chipset will
probably multiplexes between datapin belonging to ISA and to IDE. The
bandwidth is shared and likely result is the both buses are slow.</p>
<p>FinALI chipset is worse though, it multiplexes the IDE bus with PCI
:-P.</p>
<p>The top speed of the UMC IDE in linux is around 2.10MB/s</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sda <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">109MiB</span> 0:00:50 <span class="pp">[</span><span class="ss">2.14MiB/s</span><span class="pp">]</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">111MiB</span> 0:00:51 <span class="pp">[</span><span class="ss">2.05MiB/s</span><span class="pp">]</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">113MiB</span> 0:00:52 <span class="pp">[</span><span class="ss">2.08MiB/s</span><span class="pp">]</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">115MiB</span> 0:00:53 <span class="pp">[</span><span class="ss">2.19MiB/s</span><span class="pp">]</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">117MiB</span> 0:00:54 <span class="pp">[</span><span class="ss">2.18MiB/s</span><span class="pp">]</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">119MiB</span> 0:00:55 <span class="pp">[</span><span class="ss">2.15MiB/s</span><span class="pp">]</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sda bs=512 count=100000 of=/dev/null</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 36.30s</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 7.63s</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 27.12s</span></code></pre></div>
<p>As we have a modern BIOS implementation, we can use bigger and faster
drives to lower the latencies (spoiler: it won’t make much of the
difference).</p>
<h3 id="pata-sata-adapter">PATA-SATA adapter</h3>
<figure>
<img src="./images/pata_sata.jpg" title="PATA-SATA adapter"
alt="PATA-SATA adapter" />
<figcaption aria-hidden="true">PATA-SATA adapter</figcaption>
</figure>
<p>If we own this kind of adapter we can use it to connect any SATA
drive to our coreboot motherboards. This will also allow us to have
bigger drives as IDE/PATA drives ended with smaller capacities than
current SATA drives (of course only if the OS supports it).</p>
<p>This can lead to situation where we can boot linux from a drive like
this:</p>
<figure>
<img src="./images/3tb_hdd.jpeg" title="3TB HDD" alt="3TB HDD" />
<figcaption aria-hidden="true">3TB HDD</figcaption>
</figure>
<figure>
<img src="./images/3tb_hdd_setup.jpeg" title="3TB HDD setup"
alt="3TB HDD setup" />
<figcaption aria-hidden="true">3TB HDD setup</figcaption>
</figure>
<h4 id="exceptions">Exceptions</h4>
<p>On <a
href="https://theretroweb.com/motherboards/s/abit-ab-pb4-rev-1.3">Abit
AB-PB4 board</a> there is a problem, that even with the seabios the
PATA-SATA adapter connected drive may fail to boot. Sometimes the device
is detected but its identification string is returned damaged and the
following accesses fail, sometimes even the identification fails.</p>
<p><a
href="https://theretroweb.com/motherboards/s/biostar-mb-8425uud-a">Biostar
MB-8433UUD</a> worked from the start. Maybe the failures on other board
is caused with weaker I/O drivers/buffers, which don’t have voltage
levels compatible with the modern adapter chip? It is still a
mystery.</p>
<h3 id="pci-ide-adapter">PCI IDE adapter</h3>
<p>If the integrated IDE controller is slow, let’s use an external PCI
IDE card.</p>
<figure>
<img src="./images/VT6421A_ide.jpg" title="VT6421A SATA/PATA card"
alt="VT6421A SATA/PATA card" />
<figcaption aria-hidden="true">VT6421A SATA/PATA card</figcaption>
</figure>
<p>A funny fact: this card has a fake ROM flash. According to the <a
href="https://archive.org/details/bitsavers_viaTechnolTARAIDControllerRev1.020081014_490580/page/n11/mode/2up">VIA
6421A datasheet</a>:</p>
<figure>
<img src="./images/VT6421A_lpc.png" title="VT6421A LPC interface"
alt="VT6421A LPC interface" />
<figcaption aria-hidden="true">VT6421A LPC interface</figcaption>
</figure>
<p>The ROM should be stored in LPC flash, but the chip is marked as
parallel flash with a datecode before LPC was even invented :-D.</p>
<p>With ROM is being unavailable there may be some limitations of
adapter’s features (e.g. software raid).</p>
<p>After connecting the drive via native SATA, we can read the drive up
to 9.1MiB/s:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sda <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">621MiB</span> 0:01:04 <span class="pp">[</span><span class="ss">8.85MiB/s</span><span class="pp">]</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">630MiB</span> 0:01:05 <span class="pp">[</span><span class="ss">9.15MiB/s</span><span class="pp">]</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">639MiB</span> 0:01:06 <span class="pp">[</span><span class="ss">9.12MiB/s</span><span class="pp">]</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">648MiB</span> 0:01:07 <span class="pp">[</span><span class="ss">8.78MiB/s</span><span class="pp">]</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">657MiB</span> 0:01:08 <span class="pp">[</span><span class="ss">9.20MiB/s</span><span class="pp">]</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">666MiB</span> 0:01:09 <span class="pp">[</span><span class="ss">9.11MiB/s</span><span class="pp">]</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sda bs=512 count=100000 of=/dev/null</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 15.83s</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 3.44s</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 12.30s</span></code></pre></div>
<h3 id="pci-usb-card">PCI USB card</h3>
<p>SeaBIOS supports boot via USB flash too. If we put a USB controller
card into the machine we can boot any mass storage device. Ideally the
compatibility should be so good that we can boot from something like
this:</p>
<figure>
<img src="./images/chain.jpg" title="USB-SATA-PATA-CF adapter"
alt="USB-SATA-PATA-CF adapter" />
<figcaption aria-hidden="true">USB-SATA-PATA-CF adapter</figcaption>
</figure>
<p>Sadly it seems the SeaBIOS timeouts with waiting on USB controller,
so booting is not possible yet. Maybe it is caused by interrupt setup,
but I wasn’t able to find the solution. Both OHCI and UHCI drivers
doesn’t work. When the kernel boot is done and drivers are loaded, the
USB works fine.</p>
<h4 id="opti-firelink-usb-1.1-ohci">OPTi Firelink, USB 1.1 OHCI</h4>
<p>OPTi Firelink PCI card is based on <a
href="https://theretroweb.com/chips/4713#docs">OPTi 82C861 chip</a>.</p>
<figure>
<img src="./images/opti_firelink.jpg" title="OPTi Firelink USB"
alt="OPTi Firelink" />
<figcaption aria-hidden="true">OPTi Firelink</figcaption>
</figure>
<p>Maximum attained speed is:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sdb <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ex">89.8MiB</span> 0:01:34 [ 954KiB/s]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ex">90.8MiB</span> 0:01:35 [ 984KiB/s]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="ex">91.7MiB</span> 0:01:36 <span class="pp">[</span><span class="ss">1006KiB/s</span><span class="pp">]</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="ex">92.6MiB</span> 0:01:37 [ 945KiB/s]</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sdb bs=512 count=100000 of=/dev/null</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 51.62s</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 4.08s</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 16.52s</span></code></pre></div>
<h4 id="via-vt6212l-usb-2.0-uhciehci">VIA VT6212L, USB 2.0
(UHCI+EHCI)</h4>
<p>This <a href="https://theretroweb.com/chips/4482#docs">VIA
VT6212L</a> based card has USB 2.0 (EHCI) and USB 1.1 (UHCI) controller.
We can benchmark both just by having the other driver disabled.</p>
<figure>
<img src="./images/vt6212_usb.jpg" title="VIA VT6212L USB"
alt="VIA VT6212L USB" />
<figcaption aria-hidden="true">VIA VT6212L USB</figcaption>
</figure>
<p>UHCI (1.1) benchmark:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sdb <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ex">10.0MiB</span> 0:00:12 [ 819KiB/s]</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sdb bs=512 count=100000 of=/dev/null</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 58.40s</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 3.78s</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 16.71s</span></code></pre></div>
<p>It seems UHCI has a slower transfer rate. That matches the historical
observation the UHCI controller specification was less efficient than
OHCI controller specification.</p>
<p>EHCI (2.0) benchmark:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sdb <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">166MiB</span> 0:00:34 <span class="pp">[</span><span class="ss">4.67MiB/s</span><span class="pp">]</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">172MiB</span> 0:00:35 <span class="pp">[</span><span class="ss">5.11MiB/s</span><span class="pp">]</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">176MiB</span> 0:00:36 <span class="pp">[</span><span class="ss">4.89MiB/s</span><span class="pp">]</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">181MiB</span> 0:00:37 <span class="pp">[</span><span class="ss">4.55MiB/s</span><span class="pp">]</span></span></code></pre></div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sdb bs=512 count=100000 of=/dev/null</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 36.28s</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 6.37s</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 29.87s</span></code></pre></div>
<h3 id="even-faster">Even faster!</h3>
<p>Having a modern PCI USB or SATA controller is fine, but these are now
getting older and older. Why limit ourselves to the old bus if there
already exists a more modern one. And thanks to the modern BIOS
implementation we can actually do that!</p>
<figure>
<img src="./images/pci_to_pcie_front.jpg" title="PCI/PCIe adapter front"
alt="PCI/PCIe adapter front" />
<figcaption aria-hidden="true">PCI/PCIe adapter front</figcaption>
</figure>
<figure>
<img src="./images/pci_to_pcie_back.jpg" title="PCI/PCIe adapter back"
alt="PCI/PCIe adapter back" />
<figcaption aria-hidden="true">PCI/PCIe adapter back</figcaption>
</figure>
<p>This card works as a virtual PCI-PCI bridge with one side having the
old PCI bus and the other side having the PCIe link. On the protocol
level there is almost no difference between PCI and PCIe so any data
transfer can be just translated between both interfaces. According to
the <a
href="https://web.archive.org/web/20240912191629/https://www.digchip.com/datasheets/download_datasheet.php?id=7369774&amp;part-number=PEX8111-AA66FBCF">PEX8111
datasheet</a> the chip can work both ways (creating a PCI slot on a PCIe
machine), but this functionality is disabled by the card wiring (there
are reversed cards on the market too).</p>
<p>If we plug the PXE8111/2 card into 486, it … will not work. Actually
some other PCI cards also may not work. These will require 3.3V supply
rail, however the most of the 486 boards doesn’t have 3.3V pins
implemented. The solution is <em>easy</em>, we can just solder an
external 3.3V power source. This will add the 3.3V capability only to a
single PCI slot. I strongly recommend to measure the 3.3V pins are
<em>really</em> not connected to anything.</p>
<p>Now we can try the most modern devices, so let’s try a PCIe SATA
controller card.</p>
<figure>
<img src="./images/pcie_sata.jpg" title="PCIe SATA" alt="PCIe SATA" />
<figcaption aria-hidden="true">PCIe SATA</figcaption>
</figure>
<p>and the resulting benchmark:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /dev/sda <span class="kw">|</span> <span class="ex">pv</span> <span class="op">&gt;</span> /dev/null</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">155MiB</span> 0:00:16 <span class="pp">[</span><span class="ss">9.07MiB/s</span><span class="pp">]</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">165MiB</span> 0:00:17 <span class="pp">[</span><span class="ss">9.17MiB/s</span><span class="pp">]</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">173MiB</span> 0:00:18 <span class="pp">[</span><span class="ss">8.76MiB/s</span><span class="pp">]</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">183MiB</span> 0:00:19 <span class="pp">[</span><span class="ss">9.29MiB/s</span><span class="pp">]</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">192MiB</span> 0:00:20 <span class="pp">[</span><span class="ss">9.48MiB/s</span><span class="pp">]</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">201MiB</span> 0:00:21 <span class="pp">[</span><span class="ss">8.84MiB/s</span><span class="pp">]</span></span></code></pre></div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="bu">time</span> dd if=/dev/sda bs=512 count=100000 of=/dev/null</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records in</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="ex">100000+0</span> records out</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="ex">real</span>    0m 20.62s</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="ex">user</span>    0m 3.95s</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="ex">sys</span>     0m 16.14s</span></code></pre></div>
<p>It is surprisingly slow, PCI bus generally should be faster. However
as UMC is from around time when PCI was invented, it will probably don’t
have all the optimizations. IBC (southbridge) has to arbitrate between
PCI and ISA too. I could be just that linux on 486 has too big overhead
to read the drive faster.</p>
<h4 id="vanilla-bioses">Vanilla BIOSes</h4>
<p>The PCI/PCIe adapter can be used with vanilla Biostar BIOS too. If
the BIOS doesn’t like the card (too large BAR, too modern API of the
option ROM) it will often disable the PCI/PCIe bridge altogether (and
leave the devices <em>behind</em> the bridge in inconsistent
configuration). Linux can fix this by re-enumerating the PCI system, the
patch is included <a
href="https://github.com/pc2005cz/TheUltimate486Upgrade/tree/main/resources/kernel.patch">in
the patchset</a>.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -728,6 +888,14 @@ static struct chipset early_qrk[] __initdata = {</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="va">+       { PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_496,</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="va">+         PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, my_486_bus_num_rescan},</span></span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> __init _bus_reset<span class="op">(</span>u8 b<span class="op">)</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>u8 d<span class="op">=</span><span class="dv">0</span><span class="op">;</span>d<span class="op">&lt;</span><span class="dv">32</span><span class="op">;</span>d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>u8 f<span class="op">=</span><span class="dv">0</span><span class="op">;</span>f<span class="op">&lt;</span><span class="dv">8</span><span class="op">;</span>f<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>            u32 dvid<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>            u8 hdr<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">//load DID VID</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>            dvid <span class="op">=</span> read_pci_config<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>dvid <span class="op">==</span> <span class="bn">0x00000000</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>dvid <span class="op">==</span> <span class="bn">0xffffffff</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>                <span class="co">//nothing, skip</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">//get header type</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>            hdr <span class="op">=</span> read_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0xe</span><span class="op">);</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>hdr <span class="op">&amp;</span> <span class="bn">0x7f</span><span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>                <span class="co">//bridge header, do bridge</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">//primary bus number</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x18</span><span class="op">,</span> <span class="bn">0xff</span><span class="op">);</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">//secondary bus number</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x19</span><span class="op">,</span> <span class="bn">0xff</span><span class="op">);</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">//subordinate bus number, set to</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x1a</span><span class="op">,</span> <span class="bn">0xff</span><span class="op">);</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!(</span>hdr <span class="op">&amp;</span> <span class="bn">0x80</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a>                <span class="co">//not multifunction, skip nonzero rest</span></span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a>                <span class="co">//expects nonzero multifunction bit 7 == 1</span></span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> u8 __init _bus_depth_set<span class="op">(</span>u8 b<span class="op">,</span> u8 next<span class="op">)</span></span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-41"><a href="#cb46-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>next <span class="op">&gt;=</span> <span class="dv">250</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-42"><a href="#cb46-42" aria-hidden="true" tabindex="-1"></a>        pr_info<span class="op">(</span><span class="st">&quot;PCI fixup bus num overflow</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb46-43"><a href="#cb46-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> next<span class="op">;</span></span>
<span id="cb46-44"><a href="#cb46-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-45"><a href="#cb46-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-46"><a href="#cb46-46" aria-hidden="true" tabindex="-1"></a>    _bus_reset<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb46-47"><a href="#cb46-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-48"><a href="#cb46-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>u8 d<span class="op">=</span><span class="dv">0</span><span class="op">;</span>d<span class="op">&lt;</span><span class="dv">32</span><span class="op">;</span>d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb46-49"><a href="#cb46-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>u8 f<span class="op">=</span><span class="dv">0</span><span class="op">;</span>f<span class="op">&lt;</span><span class="dv">8</span><span class="op">;</span>f<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb46-50"><a href="#cb46-50" aria-hidden="true" tabindex="-1"></a>            u16 vid<span class="op">,</span> did<span class="op">;</span></span>
<span id="cb46-51"><a href="#cb46-51" aria-hidden="true" tabindex="-1"></a>            u8 hdr<span class="op">;</span></span>
<span id="cb46-52"><a href="#cb46-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-53"><a href="#cb46-53" aria-hidden="true" tabindex="-1"></a>            <span class="co">//load VID</span></span>
<span id="cb46-54"><a href="#cb46-54" aria-hidden="true" tabindex="-1"></a>            vid <span class="op">=</span> read_pci_config_16<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb46-55"><a href="#cb46-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>vid <span class="op">==</span> <span class="bn">0x0000</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>vid <span class="op">==</span> <span class="bn">0xffff</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-56"><a href="#cb46-56" aria-hidden="true" tabindex="-1"></a>                <span class="co">//nothing, skip</span></span>
<span id="cb46-57"><a href="#cb46-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb46-58"><a href="#cb46-58" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-59"><a href="#cb46-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-60"><a href="#cb46-60" aria-hidden="true" tabindex="-1"></a>            <span class="co">//load DID</span></span>
<span id="cb46-61"><a href="#cb46-61" aria-hidden="true" tabindex="-1"></a>            did <span class="op">=</span> read_pci_config_16<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb46-62"><a href="#cb46-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-63"><a href="#cb46-63" aria-hidden="true" tabindex="-1"></a>            <span class="co">//get header type</span></span>
<span id="cb46-64"><a href="#cb46-64" aria-hidden="true" tabindex="-1"></a>            hdr <span class="op">=</span> read_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0xe</span><span class="op">);</span></span>
<span id="cb46-65"><a href="#cb46-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>hdr <span class="op">&amp;</span> <span class="bn">0x7f</span><span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-66"><a href="#cb46-66" aria-hidden="true" tabindex="-1"></a>                <span class="co">//bridge header, do bridge</span></span>
<span id="cb46-67"><a href="#cb46-67" aria-hidden="true" tabindex="-1"></a>                u8 next_new<span class="op">;</span></span>
<span id="cb46-68"><a href="#cb46-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-69"><a href="#cb46-69" aria-hidden="true" tabindex="-1"></a>                <span class="co">//primary bus number</span></span>
<span id="cb46-70"><a href="#cb46-70" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x18</span><span class="op">,</span> b<span class="op">);</span></span>
<span id="cb46-71"><a href="#cb46-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-72"><a href="#cb46-72" aria-hidden="true" tabindex="-1"></a>                <span class="co">//secondary bus number</span></span>
<span id="cb46-73"><a href="#cb46-73" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x19</span><span class="op">,</span> next<span class="op">);</span></span>
<span id="cb46-74"><a href="#cb46-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-75"><a href="#cb46-75" aria-hidden="true" tabindex="-1"></a>                pr_info<span class="op">(</span><span class="st">&quot;PCI fix scan </span><span class="sc">%04x</span><span class="st">:</span><span class="sc">%04x</span><span class="st"> </span><span class="sc">%2u</span><span class="st">:</span><span class="sc">%02u</span><span class="st">.</span><span class="sc">%1u</span><span class="st"> -&gt; </span><span class="sc">%2u</span><span class="st">, next:</span><span class="sc">%2u\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb46-76"><a href="#cb46-76" aria-hidden="true" tabindex="-1"></a>                    vid<span class="op">,</span> did<span class="op">,</span></span>
<span id="cb46-77"><a href="#cb46-77" aria-hidden="true" tabindex="-1"></a>                    b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span></span>
<span id="cb46-78"><a href="#cb46-78" aria-hidden="true" tabindex="-1"></a>                    next<span class="op">,</span></span>
<span id="cb46-79"><a href="#cb46-79" aria-hidden="true" tabindex="-1"></a>                    next<span class="op">+</span><span class="dv">1</span></span>
<span id="cb46-80"><a href="#cb46-80" aria-hidden="true" tabindex="-1"></a>                <span class="op">);</span></span>
<span id="cb46-81"><a href="#cb46-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-82"><a href="#cb46-82" aria-hidden="true" tabindex="-1"></a>                next_new <span class="op">=</span> _bus_depth_set<span class="op">(</span>next<span class="op">,</span> next <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb46-83"><a href="#cb46-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-84"><a href="#cb46-84" aria-hidden="true" tabindex="-1"></a>                <span class="co">//subordinate bus number, set to</span></span>
<span id="cb46-85"><a href="#cb46-85" aria-hidden="true" tabindex="-1"></a>                write_pci_config_byte<span class="op">(</span>b<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> <span class="bn">0x1a</span><span class="op">,</span> next_new <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb46-86"><a href="#cb46-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-87"><a href="#cb46-87" aria-hidden="true" tabindex="-1"></a>                next <span class="op">=</span> next_new<span class="op">;</span></span>
<span id="cb46-88"><a href="#cb46-88" aria-hidden="true" tabindex="-1"></a>                <span class="co">// return next_new;</span></span>
<span id="cb46-89"><a href="#cb46-89" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-90"><a href="#cb46-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-91"><a href="#cb46-91" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!(</span>hdr <span class="op">&amp;</span> <span class="bn">0x80</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-92"><a href="#cb46-92" aria-hidden="true" tabindex="-1"></a>                <span class="co">//not multifunction, skip nonzero rest</span></span>
<span id="cb46-93"><a href="#cb46-93" aria-hidden="true" tabindex="-1"></a>                <span class="co">//expects nonzero multifunction bit 7 == 1</span></span>
<span id="cb46-94"><a href="#cb46-94" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-95"><a href="#cb46-95" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-96"><a href="#cb46-96" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-97"><a href="#cb46-97" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-98"><a href="#cb46-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-99"><a href="#cb46-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> next<span class="op">;</span></span>
<span id="cb46-100"><a href="#cb46-100" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-101"><a href="#cb46-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-102"><a href="#cb46-102" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> __init my_486_bus_num_rescan<span class="op">(</span><span class="dt">int</span> bus<span class="op">,</span> <span class="dt">int</span> slot<span class="op">,</span> <span class="dt">int</span> func<span class="op">)</span></span>
<span id="cb46-103"><a href="#cb46-103" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-104"><a href="#cb46-104" aria-hidden="true" tabindex="-1"></a>    pr_info<span class="op">(</span><span class="st">&quot;486 bus num rescan (early-quirks.c)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb46-105"><a href="#cb46-105" aria-hidden="true" tabindex="-1"></a>    _bus_depth_set<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb46-106"><a href="#cb46-106" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If the <code>bus</code> settings is left with inconsistent values the
linux kernel re-enumeration would fail to find devices. The patch will
find all PCI-PCI bridges and devices and it will then reset the
<code>bus</code> number to a deterministic value, which is
understandable in the PCI re-enumeration code. Using any PCIe card
(behind the bridge) before the linux re-enumerated the PCI system is
obviously not possible.</p>
<h4 id="outside-biostar-motherboard">Outside Biostar motherboard</h4>
<p>This is what started UMC reverse engineering project. If we try to
use PCI/PCIe adapter with a card with busmaster capability in any of
non-UMC chipsets these chipsets will freeze.</p>
<p>When developing a PCI host there is a risk to make a fatal mistake by
assuming a bridge doesn’t have the instant control between primary and
secondary sides and it may already be servicing a request, which under
some conditions <em>must</em> be finished. If there is also another
request which must be finished on the host side the host side may freeze
in a deadlock (assuming ~2010 PCIe/PCI bridge implements a valid
specification … there <em>are</em> some erratas for a newer versions of
the PEX8xxx chip).</p>
<p>Well Intel, ALI and SiS developers have made this mistake in 90s (and
Intel being also the initial developer of PCI specification :-D). Tested
boards <a
href="https://theretroweb.com/motherboards/s/zida-4dps-3-x">Zida
4DPS</a> (with SiS 496NU/497NV chipset), <a
href="https://theretroweb.com/motherboards/s/abit-ab-pb4-rev-1.3">ABit
AB-PB4</a> (FinALI) and <a
href="https://theretroweb.com/motherboards/s/intel-classic-pci-ed-ninja">Intel
Classic/PCI ED Ninja</a> (Intel 420EX) will freeze <a
href="https://elixir.free-electrons.com/linux/v6.3.9/source/drivers/ata/libahci.c#L760">at
this code</a>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* enable FIS reception */</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> readl<span class="op">(</span>port_mmio <span class="op">+</span> PORT_CMD<span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">|=</span> PORT_CMD_FIS_RX<span class="op">;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    writel<span class="op">(</span>tmp<span class="op">,</span> port_mmio <span class="op">+</span> PORT_CMD<span class="op">);</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* flush */</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    readl<span class="op">(</span>port_mmio <span class="op">+</span> PORT_CMD<span class="op">);</span></span></code></pre></div>
<p>The MMIO register on a PCI device is first requested to read, then it
is written and when it is requested to read back (all data should be
flushed) the system will freezes. We can actually measure the address
pins of the CPU and get the correct address of the MMIO register in a
PCI BAR.</p>
<p>Some of the code may be fixed by creating a workaround. We can insert
a dummy I/O port read between these MMIO access instructions, but it can
be only fixed so far. If a bus master function is enabled (PCI device
will start to write data to the host on its own) the freeze will always
eventually occur.</p>
<p>The specific implementation and corner case may differ between
different manufacturers, but the result is same: frozen bus as CPU is
retrying to access the register and is failing to do so. Actually it was
possible to unfreeze the bus for a short time period by forcing the CPU
to backoff the bus (I think shorting /BOFF signal to ground). This would
probably add a time to flush the data from the bridge. It could be
possible to somehow monitor the bus with CPLD/FPGA and unstalling the
bus if collision is detected. Multiple shorting of the BOFF pin cause a
fatal system crash (probably a bad timing specification of a screwdriver
:-D).</p>
<p>Actually it seems at least SiS tried to fix the issue as seen in the
chapter <a
href="https://theretroweb.com/chipset/documentation/4967-2-649447c6a7c50999895435.pdf">“2.3.9.
CPU Back off support for PCI Bus PCI-to-PCI Bridge” of the datasheet</a>
(on the page 32):</p>
<figure>
<img src="./images/sis_pci_bug.png" title="SiS PCI deadlock bug"
alt="SiS PCI deadlock bug" />
<figcaption aria-hidden="true">SiS PCI deadlock bug</figcaption>
</figure>
<p>If the fix is working was not tested as the purple/pink sections of
the datasheets are implemented only for “PR” (maybe but improbably “OR”
too) revision of the chipset and I didn’t own the board with this
revision (when I was testing that) and also the pins used for CPU
backoff are muxed with additional DRAM row address strobe signals and it
is highly probable most motherboard manufacturers will opt for more
memory than for the fixed PCI.</p>
<p><a href="https://theretroweb.com/chipsets/174#docs">FinALI
datasheet</a> doesn’t mention the bug at all so maybe they weren’t even
aware of that? (but the chipset was manufactured even in the year
2006!</p>
<figure>
<img src="./images/finali_datecode.png" title="Late FinALI datecode"
alt="Late FinALI datecode" />
<figcaption aria-hidden="true">Late FinALI datecode</figcaption>
</figure>
<p>Also it seems there are two revisions (A1 vs B1) of the FinALI
southbridge chip (the one which does the PCI bus arbitration) and I have
a board with the older one. Maybe the newer revision has this bug
somehow fixed.</p>
<p><a
href="https://theretroweb.com/chipset/documentation/intld030-1-253-64b53b2e24669230973923.pdf">Intel
datasheet for Intel 420EX Aries</a> a chapter 4.4.1 “PSC Supports Other
PCI Bridges” on the page 103:</p>
<figure>
<img src="./images/intel_pci_bug.png" title="Intel PCI deadlock bug"
alt="Intel PCI deadlock bug" />
<figcaption aria-hidden="true">Intel PCI deadlock bug</figcaption>
</figure>
<p>just states it doesn’t support more than 1 PCI bus master, which
practically excludes most of the modern use cases of PCI-PCI bridges. I
wonder if pentium chipsets had the same bug too. The board was borrowed
so I didn’t test many things, but it froze nonetheless.</p>
<p>Also my Biostar MB-8433UUD board has a fairly late revision of the
chipset (ETS/DYS) and previous revisions may had this bug also
<em>included</em>. The tests from other owners would be appreciated
;-).</p>
<p>Other chipset manufacturer PCI validity was not tested but I would
suspect some will also have the same problem.</p>
<p>Another interesting thing is the UMC is PCI oriented chipset whereas
the rest are VLB oriented chipsets. UMC northbridge requests the PCI bus
from the southbridge (which does the PCI arbitration) in the same way as
any general PCI device would have to do. It may be possible this
topology created enough situations which led to a more correct
implementation. This could also mean VLB oriented chipsets will also
probably have the bug whereas PCI oriented chipsets could be OK.</p>
<h3 id="other-pcie-cards">Other PCI(e) cards</h3>
<p>With working modern BIOS, PCIe bridge and an ability to add 3.3V
supply almost any PCI(e) card can be used. I didn’t make most of the
test outside just posting but here is a partial list:</p>
<ul>
<li>USB 1.1 PCI card (Opti chipset)</li>
<li>USB 2.0 PCI card (VIA 6212L chipset)</li>
<li>Various Realtek RTL8139D 10/100M ethernet PCI card</li>
<li>3com 10/100 ethernet PCI card with iPXE chip</li>
<li>Adaptec SCSI PCI card, option ROM required PIRQ table settings</li>
<li>Compaq Smart Array 221 Controller PCI, missing in subsequent
reboots, fails (well it’s a classical compaq compatibility with standard
PC)</li>
<li>Atheros PCI 802.11b wifi PCI card</li>
<li>Weitek Power 9100 GPU works in MSDOS :-O</li>
<li>Different SVGA PCI cards</li>
<li>SATA PCIe controller</li>
<li>ATI RAGE XL graphic card</li>
</ul>
<p>But one type of the card comes to mind (and subtle references were
posted during the last year on the retroweb discord &gt;-D). According
to Vogons forum threads <a
href="https://www.vogons.org/viewtopic.php?t=27710">“Fastest PCI
graphics card in a 486”</a> or <a
href="https://www.vogons.org/viewtopic.php?t=33879">“Modern graphics on
a 486”</a> the best card for 486 is from around GeForce2/4…</p>
<p>Well not anymore! GPU cards, which are supported in the linux, have
the source code, therefore they can be compiled for any
architecture.</p>
<p>I increase the bar up to AMD Radeon RX460</p>
<figure>
<img src="./images/polaris_front.jpg" title="AMD Radeon RX460 front"
alt="AMD Radeon RX460 front" />
<figcaption aria-hidden="true">AMD Radeon RX460 front</figcaption>
</figure>
<figure>
<img src="./images/polaris_in_486.jpg" title="AMD Radeon RX460 in 486"
alt="AMD Radeon RX460 in 486" />
<figcaption aria-hidden="true">AMD Radeon RX460 in 486</figcaption>
</figure>
<p>Only limitation is I don’t have a newer GPU, but if somebody wants to
increase the bar with lets say 2024’s Radeon RX 7900 XT I say go for it
:-D.</p>
<p>This applies to linux as windows drivers are closed source and mostly
to AMD GPUs as nvidia has a closed source drivers for linux too and
nouveau is most likely suboptimal.</p>
<h1 id="graphics-with-486">Graphics with 486</h1>
<p>OK let’s back up a little. If we have a GPU contest now we should
start from the bottom.</p>
<p>The SeaBIOS should generally support any video BIOS, but there may be
limitations. First the SeaBIOS doesn’t support ISA bus completely. If we
want to see the video from ISA card, we need to change video BIOS search
algorithm.</p>
<p>Originally video BIOS was located in segment C (0xc0000), usually up
to 32kiB (up to address 0xc8000). Modern video BIOSes can be easily
64kiB and are located in PCI region space. The best aproach of option
ROM scan is to test PCI devices first and then check the ISA segment C
region. If a PCI video card is found (and possibly if CMOS settings
allows its use as a primary card), the chipset needs to switch the C
segment to be a RAM shadows and copy the option ROM from the video card
there. If no PCI video is found (or if CMOS disables it) then chipset
needs to switch segment C to point to ISA space and search the option
ROM there. After that it can also make a copy into the shadow RAM.
SeaBIOS will probably need to be patched to be aware of different sizes
of shadow regions for each different chipsets (this was only tested on
UMC chipset).</p>
<h2 id="seabios-bugs">SeaBIOS bugs</h2>
<p>No so fast. It seems there is a hidden bug somewhere or maybe the
BIOS implementation is so modern that some of the tests crashes. The
crashes are also dependent between different video cards, which means
there may be multiple bugs.</p>
<p>Some applications which use VBE routines will just crash, there are
almost impossible to debug as MSDOS doesn’t have any memory protection
and any application crash will crash the entire system. Also it doesn’t
help the application (for example Quake) starts in 16bit mode and then
it jumps or even decompress more binary into 32-bit protected mode. It
is almost impossible to disassemble even in <a
href="https://ghidra-sre.org/">ghidra</a>. Observed inicialization of
the program shows it will usually copy incorrect data to a wrong place
and it will eventually jump there triggering an invalid operation.
Programs with CWSDPMI DPMI host can be fixed by using the newest version
of the DPMI driver (e.g. Quake benchmark). But the bug is just hidden,
because the vanilla BIOS usually works flawlessly in the same
configuration.</p>
<p>It also seems the VBE implementation in PCIe GPUs is somehow bugged
itself and slower (which is more important).</p>
<p>With this spoken we can compare some measurements:</p>
<style>
.odd {
    background: lightgray;
}
.even {
    background: beige;
}
</style>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">3Dbench slower PCs</th>
<th style="text-align: left;">3Dbench faster PCs</th>
<th style="text-align: left;">Chris’s 3D</th>
<th style="text-align: left;">Chris’s 3D 640x480</th>
<th style="text-align: left;">PCPlayer</th>
<th style="text-align: left;">PCPlayer 640x480</th>
<th style="text-align: left;">Doom min details</th>
<th style="text-align: left;">Doom max details</th>
<th style="text-align: left;">Quake timedemo</th>
<th style="text-align: left;">Landmark Video</th>
<th style="text-align: left;">Topbench</th>
<th style="text-align: left;">Checkit BIOS video speed</th>
<th style="text-align: left;">Checkit direct video speed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">TVGA9000i-1 (ISA 16bit)</td>
<td style="text-align: left;">30.3</td>
<td style="text-align: left;">29.7</td>
<td style="text-align: left;">21.7</td>
<td style="text-align: left;">6.2</td>
<td style="text-align: left;">13.5</td>
<td style="text-align: left;">3.8</td>
<td style="text-align: left;">57.63</td>
<td style="text-align: left;">11.46</td>
<td style="text-align: left;">10.7</td>
<td style="text-align: left;">2078.31</td>
<td style="text-align: left;">125</td>
<td style="text-align: left;">1890</td>
<td style="text-align: left;">551787</td>
</tr>
<tr class="even">
<td style="text-align: left;">ATI RageXL (PCI)</td>
<td style="text-align: left;">83.3</td>
<td style="text-align: left;">79.7</td>
<td style="text-align: left;">55.5</td>
<td style="text-align: left;">13.1</td>
<td style="text-align: left;">19.9</td>
<td style="text-align: left;">6.7</td>
<td style="text-align: left;">142.27</td>
<td style="text-align: left;">46.48</td>
<td style="text-align: left;">14.2</td>
<td style="text-align: left;">15603.81</td>
<td style="text-align: left;">273</td>
<td style="text-align: left;">42650</td>
<td style="text-align: left;">551787</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ATI HD5450 (PCIe bridge)</td>
<td style="text-align: left;">55.5</td>
<td style="text-align: left;">54.7</td>
<td style="text-align: left;">56.2</td>
<td style="text-align: left;">crash</td>
<td style="text-align: left;">19.9</td>
<td style="text-align: left;">glitch 6.4</td>
<td style="text-align: left;">114.20</td>
<td style="text-align: left;">28.83</td>
<td style="text-align: left;">14.1</td>
<td style="text-align: left;">5585.45</td>
<td style="text-align: left;">118</td>
<td style="text-align: left;">6727</td>
<td style="text-align: left;">836333</td>
</tr>
<tr class="even">
<td style="text-align: left;">AMD RX460 (PCIe bridge)</td>
<td style="text-align: left;">55.5</td>
<td style="text-align: left;">54.7</td>
<td style="text-align: left;">93.7</td>
<td style="text-align: left;">not supported</td>
<td style="text-align: left;">19.9</td>
<td style="text-align: left;">crash</td>
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">27.90</td>
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">TODO</td>
<td style="text-align: left;">100</td>
<td style="text-align: left;">6339</td>
<td style="text-align: left;">836333</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ATI HD4550 (PCIe bridge)</td>
<td style="text-align: left;">55.5</td>
<td style="text-align: left;">54.7</td>
<td style="text-align: left;">56.2</td>
<td style="text-align: left;">weird overflow 12.5</td>
<td style="text-align: left;">19.9</td>
<td style="text-align: left;">6.4</td>
<td style="text-align: left;">114.03</td>
<td style="text-align: left;">28.69</td>
<td style="text-align: left;">14.1</td>
<td style="text-align: left;">5585.45</td>
<td style="text-align: left;">118</td>
<td style="text-align: left;">7013</td>
<td style="text-align: left;">836333</td>
</tr>
</tbody>
</table>
<p>Surprisingly PCIe cards doesn’t have the best score in the most
tests. Also lots of tests on PCIe have the same score between itselves.
This may be possible because of some “clever” VGA transfer grouping
which limits the bus? The PCI-PCIe bridge also has an internal
latency.</p>
<p>The PCIe seems to have some bugs in VBE implementations and/or there
is a bug in the SeaBIOS. Especially Chris’s 3D for VBE (640x480) shows
some different bugs (silent crash, fail with an error the resolution is
not supported, runs with chopped lines). PCPlayer 640x480 with HD5450
has some noise on top and the bottom bars. It may be possible something
overflows somewhere.</p>
<p>REst of the tests may be added in the future.</p>
<p>Quake benchmark (DOS Benchmark Pack) running from 3TB drive:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/IvA7IXpEBAc" title="The Ultimate 486 Upgrade: Quake benchmark running from 3TB drive" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>DOOM (DOS Benchmark Pack):</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/AbkFJxC_FWk" title="The Ultimate 486 Upgrade: DOS Benchmark Pack, DOOM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Anyway the best video test I’ve seen is a 256 bytes (!) demo called
<a href="https://www.pouet.net/prod.php?which=3396">Wolf</a>.</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/MKfTCFH9wY0" title="The Ultimate 486 Upgrade: 256 bytes demo Wolf" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h2 id="linux">Linux</h2>
<p>Well none of this is relevant in linux which uses targeted drivers
and not generic VBE calls (except for vesafb and only at boot, I
think).</p>
<p>If we have an AMD Radeon and we want to use it fully, we need to
compile a driver in the kernel and an userspace driver too.</p>
<p>Modern AMD GPUs have two kernel drivers (with a slight overlay):
<code>radeon</code> and <code>amdgpu</code>. The first one should
support almost everything between around 7xxx and early GCN. The second
one (amdgpu) should support anything with GCN architecture onward. This
usually causes the driver to take really a lot of space. We can shrink
the size of the driver by commenting any unused chips in the switch case
section in <a
href="https://elixir.free-electrons.com/linux/v6.3.9/source/drivers/gpu/drm/radeon/radeon_asic.c#L2332"><code>radeon_asic_init()</code></a>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>rdev<span class="op">-&gt;</span>family<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_R100<span class="op">:</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV100<span class="op">:</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RS100<span class="op">:</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV200<span class="op">:</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RS200<span class="op">:</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        rdev<span class="op">-&gt;</span>asic <span class="op">=</span> <span class="op">&amp;</span>r100_asic<span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_R200<span class="op">:</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV250<span class="op">:</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RS300<span class="op">:</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV280<span class="op">:</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        rdev<span class="op">-&gt;</span>asic <span class="op">=</span> <span class="op">&amp;</span>r200_asic<span class="op">;</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_R300<span class="op">:</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_R350<span class="op">:</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV350<span class="op">:</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CHIP_RV380<span class="op">:</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>rdev<span class="op">-&gt;</span>flags <span class="op">&amp;</span> RADEON_IS_PCIE<span class="op">)</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>            rdev<span class="op">-&gt;</span>asic <span class="op">=</span> <span class="op">&amp;</span>r300_asic_pcie<span class="op">;</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            rdev<span class="op">-&gt;</span>asic <span class="op">=</span> <span class="op">&amp;</span>r300_asic<span class="op">;</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span></code></pre></div>
<p>Tables which are not referenced will be optimized out (removed) along
with unused code parts.</p>
<p>I patched some parts of the GPU system to not use any cache, as it
seems 486 chipset doesn’t cache nor prefetch PCI space. That could be
wrong, but the patched code works. For example in <a
href="https://elixir.free-electrons.com/linux/v6.3.9/source/drivers/gpu/drm/radeon/radeon_object.c#L180"><code>radeon_bo_create()</code></a>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#elif defined(CONFIG_X86) &amp;&amp; !defined(CONFIG_X86_PAT)</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Don&#39;t try to enable write-combining when it can&#39;t work, or things</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">     * may be slow</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">     * See https://bugs.freedesktop.org/show_bug.cgi?id=88758</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CONFIG_COMPILE_TEST</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#warning Please enable CONFIG_MTRR and CONFIG_X86_PAT for better performance </span><span class="op">\</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="pp">     thanks to write-combining</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>bo<span class="op">-&gt;</span>flags <span class="op">&amp;</span> RADEON_GEM_GTT_WC<span class="op">)</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>        DRM_INFO_ONCE<span class="op">(</span><span class="st">&quot;Please enable CONFIG_MTRR and CONFIG_X86_PAT for &quot;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;better performance thanks to write-combining</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    bo<span class="op">-&gt;</span>flags <span class="op">&amp;=</span> <span class="op">~(</span>RADEON_GEM_GTT_WC <span class="op">|</span> RADEON_GEM_GTT_UC<span class="op">);</span></span></code></pre></div>
<p>We should always set “uncached” flag.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>bo<span class="op">-&gt;</span>flags <span class="op">|=</span> RADEON_GEM_GTT_UC<span class="op">;</span></span></code></pre></div>
<p>Uncached variants should be used in
<code>radeon_ttm_io_mem_reserve()</code> too. The rest are most likely
debugging asserts if any. Attached patches should work.</p>
<p>AMDGPU driver is architectonically very similar. It may use 64-bit
atomic access variables. IMO these can be emulated by disabling the
interrupts so we shouldn’t worry (some CPU architectures may have this
unimplemented).</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/eMYgJ9gu71Y" title="The Ultimate 486 Upgrade: Neofetch with AMD RX460" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>These drivers only form a hardware abstration layer (DRM) and a
framebuffer. The main linux rendering engine called <a
href="https://www.mesa3d.org/">Mesa3D</a> is implemented in the user
space. We need to recompile the buildroot with Xorg + Mesa3D and
companion libraries included. Patches and configuration are available,
but it may need some script hacking when being reused for a newer
buildroot version.</p>
<p>Funny fact: Mesa3D does automatically enable SSE for compilation,
which needs to be disabled and changed to i486 architecture level. The
same applies for the pixman library for bitmap manipulations. Xorg
server also intensively uses the <code>cpuid</code> instruction which
excludes all pre-CPUID processors from our experiments (future tests are
too slow for Am5x86-133 anyway).</p>
<p>After both kernel and buildroot rebuilds we can try to start the X
server. I strongly recommend to include the kernel driver for the GPU in
the modprobe blacklist, s othe driver will load only manually and not
during boot. The Xorg server should be also disabled at the boot. The
486 with the graphic system should have at least 64 MB of RAM or the
Xorg will eat entire memory and the linux will freeze/swaps to
death/crash. Especially if out of memory event kills something
important. I did testing with 128 MB of RAM and the free space of the
RAM was tight. You can also enable swap, it will be slow with integrated
IDE.</p>
<p>The most of the tests were done with ATI Radeon HD5450 as my RX460
was deemed too precious to be put into an ancient 486 machine for a long
duration. Also I needed a GPU to work/build/install :-D. AMDGPU driver
finds the RX460 and enables the framebuffer however it seems too laggy
to use and there are still problems with cacheable region
definitions.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ex">modprobe</span> radeon</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Xorg</span> <span class="at">-retro</span> <span class="at">-config</span> /etc/X11/xorg.conf <span class="op">&gt;</span> /dev/null <span class="dv">2</span><span class="op">&gt;</span> /dev/null <span class="kw">&amp;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DISPLAY</span><span class="op">=</span>:0</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">vblank_mode</span><span class="op">=</span>0</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="ex">xeyes</span></span></code></pre></div>
<p>The programs should be started each after some time. Xorg can be run
in the background but it will take a minute it even initialize. The
variable <code>DISPLAY</code> is needed for the GUI applications to know
where the X server is located. The variable <code>vblank_mode</code>
disable VSYNC so we can observe the true maximal FPS &gt;-D.</p>
<p>If everything goes right we should see in like 2 minutes eyes
watching the mouse pointer. There is no window management so all
applications will have the default window size.</p>
<p>That’s boring let’s run:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ex">glxgears</span> <span class="at">-info</span></span></code></pre></div>
<p>Let’s see the entire boot sequence:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/OAFs6M2Sl7k" title="The Ultimate 486 Upgrade: GLXgears" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>And the result log looks like that:</p>
<pre><code>GL_RENDERER   = AMD CEDAR (DRM 2.50.0 / 6.3.9-retro+)
GL_VERSION    = 4.5 (Compatibility Profile) Mesa 23.2.1
GL_VENDOR     = Mesa
...
155 frames in 5.0 seconds = 30.920 FPS
155 frames in 5.0 seconds = 30.838 FPS
156 frames in 5.0 seconds = 30.995 FPS
155 frames in 5.0 seconds = 30.899 FPS
156 frames in 5.0 seconds = 31.016 FPS
154 frames in 5.0 seconds = 30.659 FPS
156 frames in 5.0 seconds = 31.160 FPS
154 frames in 5.0 seconds = 30.700 FPS</code></pre>
<p>A classical test, it should show the FPS as it goes. It will also log
the openGL capabilities. It is funny to see having a OpenGL 4.5 GPU to
run in 486 system. The default window size can run up to 30 FPS which is
impressive. The full screen (<code>-fullscreen</code>) on 16:9 monitor
actually runs faster as there is probably smaller amount of the visible
polygons.</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/N8oJyh2pmJQ" title="The Ultimate 486 Upgrade: Fullscreen glxgears" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>And the measured FPS:</p>
<pre><code>166 frames in 5.0 seconds = 33.070 FPS
168 frames in 5.0 seconds = 33.424 FPS
166 frames in 5.0 seconds = 33.180 FPS
168 frames in 5.0 seconds = 33.421 FPS
167 frames in 5.0 seconds = 33.247 FPS
168 frames in 5.0 seconds = 33.380 FPS
166 frames in 5.0 seconds = 33.070 FPS</code></pre>
<p>If you try to run any busmaster GPU via PCI-PCI bridge on buggy
chipset, it will usually crash in a few seconds (probably caused by some
power management register modification in the driver), but sometimes few
FPS measurements were made too. It seems Intel Classic/PCI ED (Ninja)
board was faster than ABit AB-PB4 even though FinALI chipset supports
EDO RAM and Intel 420EX Aries tolerates them at most. But both boards
did soon froze anyway :-P.</p>
<h3 id="opengl-games">OpenGL games</h3>
<p>Will it run doom?</p>
<p>Yes there are some linux flavours of doom (<a
href="https://prboom.sourceforge.net/">prdoom</a>:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/83mgTZr7N0A" title="The Ultimate 486 Upgrade: PrBoom" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>And a <a
href="https://www.chocolate-doom.org/wiki/index.php/Chocolate_Doom">chocolate
doom</a>):</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/ujp8Nym1LzQ" title="The Ultimate 486 Upgrade: Chocolate Doom" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>I really loved this next game years ago, so why not to run it on a
486. However the original minimum hardware requirements was Pentium II
233MHz. As the source code was released a long time ago we can compile
it for the 486 architecture.</p>
<p>Homeworld SDL:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/af3IRL205nU" title="The Ultimate 486 Upgrade: HomeworldSDL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>It runs a <em>little</em> bit slow, but it moves :-D.</p>
<p>What about a more modern “will it run”, let’s say a minecraft? A java
VM could be eventually compiled, but only old versions of minecraft
would fit into the limited RAM (e.g. beta). Another problem are the
libraries interfacing java with the normal system if I remember
correctly, libjwgl and jinput was problematic to compile. Also compiling
such old software as minecraft beta would cause problem with modern
compilers (more unforgiving tests and warnings).</p>
<p>However we can use a different minecraft. A clone called <a
href="https://www.classicube.net/">ClassiCube</a> compiles easily and
runs smoothly with around 1 frame per second :-D.</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/4b711d7JhPs" title="The Ultimate 486 Upgrade: ClassiCube" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>We can run <a href="https://www.minetest.net/">Minetest</a> too. Just
the server should be run on another machine. Here is the dawn:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/36DimN_u1DU" title="The Ultimate 486 Upgrade: Dawn in Minetest" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>What about let’s say Half life?</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/UNpeS8k_hI4" title="The Ultimate 486 Upgrade: HalfMapper" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Well this is also a cheating, only a map viewer called <a
href="https://github.com/gzalo/HalfMapper">Half mapper</a> can fit the
memory of 486 and even then it will run <em>very</em> slowly.</p>
<p>Talking about games, <a href="https://www.openttd.org/">OpenTTD</a>
is opensource too. Funny as the original game worked in DOS but the
current engine barely moves on 486 with 128MB of RAM even though
evething was set to the low resolution settings.</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/TAaGqvGICQw" title="The Ultimate 486 Upgrade: OpenTTD" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h3 id="opengl-benchmarks">OpenGL benchmarks</h3>
<p>There is <code>glxgears</code>, but we can also run
<code>glmark2</code>:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/ZXfiE0snQGs" title="The Ultimate 486 Upgrade: GLmark2" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>With the following results:</p>
<pre><code>glmark2 --fullscreen
ATTENTION: default value of option vblank_mode overridden by environment.
=======================================================
    glmark2 2023.01
=======================================================
    OpenGL Information
    GL_VENDOR:      Mesa
    GL_RENDERER:    AMD CEDAR (DRM 2.50.0 / 6.3.9-retro+)
    GL_VERSION:     4.5 (Compatibility Profile) Mesa 23.2.1
    Surface Config: buf=32 r=8 g=8 b=8 a=8 depth=24 stencil=0 samples=0
    Surface Size:   1920x1080 fullscreen
=======================================================
[build] use-vbo=false: FPS: 17 FrameTime: 60.243 ms
[build] use-vbo=true: FPS: 59 FrameTime: 17.038 ms
[texture] texture-filter=nearest: FPS: 57 FrameTime: 17.650 ms
[texture] texture-filter=linear: FPS: 57 FrameTime: 17.574 ms
[texture] texture-filter=mipmap: FPS: 58 FrameTime: 17.512 ms
[shading] shading=gouraud: FPS: 59 FrameTime: 16.969 ms
[shading] shading=blinn-phong-inf: FPS: 59 FrameTime: 16.989 ms
[shading] shading=phong: FPS: 59 FrameTime: 17.103 ms
[shading] shading=cel: FPS: 59 FrameTime: 17.151 ms
[bump] bump-render=high-poly: FPS: 59 FrameTime: 17.049 ms
[bump] bump-render=normals: FPS: 56 FrameTime: 18.006 ms
[bump] bump-render=height: FPS: 57 FrameTime: 17.781 ms
[effect2d] kernel=0,1,0;1,-4,1;0,1,0;: FPS: 58 FrameTime: 17.303 ms
[effect2d] kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;: FPS: 58 FrameTime: 17.326 ms
[pulsar] light=false:quads=5:texture=false: FPS: 45 FrameTime: 22.256 ms
[desktop] blur-radius=5:effect=blur:passes=1:separable=true:windows=4: FPS: 21 FrameTime: 48.590 ms
[desktop] effect=shadow:windows=4: FPS: 20 FrameTime: 51.248 ms
[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 2 FrameTime: 623.544 ms
[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=subdata: FPS: 3 FrameTime: 386.951 ms
[buffer] columns=200:interleave=true:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 2 FrameTime: 583.832 ms
[ideas] speed=duration: FPS: 8 FrameTime: 133.635 ms
[jellyfish] &lt;default&gt;: FPS: 46 FrameTime: 21.853 ms
[terrain] &lt;default&gt;: FPS: 5 FrameTime: 209.967 ms
[shadow] &lt;default&gt;: FPS: 37 FrameTime: 27.250 ms
[refract] &lt;default&gt;: FPS: 20 FrameTime: 51.483 ms
[conditionals] fragment-steps=0:vertex-steps=0: FPS: 59 FrameTime: 17.038 ms
[conditionals] fragment-steps=5:vertex-steps=0: FPS: 59 FrameTime: 17.044 ms
[conditionals] fragment-steps=0:vertex-steps=5: FPS: 59 FrameTime: 16.979 ms
[function] fragment-complexity=low:fragment-steps=5: FPS: 59 FrameTime: 16.995 ms
[function] fragment-complexity=medium:fragment-steps=5: FPS: 59 FrameTime: 17.025 ms
[loop] fragment-loop=false:fragment-steps=5:vertex-steps=5: FPS: 59 FrameTime: 17.044 ms
[loop] fragment-steps=5:fragment-uniform=false:vertex-steps=5: FPS: 59 FrameTime: 17.010 ms
[loop] fragment-steps=5:fragment-uniform=true:vertex-steps=5: FPS: 59 FrameTime: 17.011 ms
=======================================================
                                  glmark2 Score: 43
=======================================================</code></pre>
<p>But still many people doesn’t know what glmark2 is. We should use
something universal. What about <a
href="https://www.geeks3d.com/furmark/">Furmark</a>?</p>
<p>There is a little bit of a problem. Furmark is made only for 64-bit
linux. A 32-bit version is only available for windows. Still we have
some options. We can use wine to emulate windows API or we can use
x86-64 emulator.</p>
<p>I will not describe details, but wine was a failed attempt. The
source code has lot of hardwired pentium level stuff and even with
patched 486 support no app will ever start. It has probably to much
overhead and eats too much RAM to be useful.</p>
<p>The second option we can use, is to compile <a
href="https://www.qemu.org/">QEMU project</a>.</p>
<p>It will emulate any CPU architecture in software and there is also a
mode to emulate only libraries and programs running in a native system.
However it doesn’t support a lots of GPU related calls, so we would need
to add the translation first. Luckily somewhere already tried that and
we can build on the top of that.</p>
<p><a
href="https://lists.gnu.org/archive/html/qemu-devel/2020-08/msg02000.html">[Bug
1890545] Re: (ARM64) qemu-x86_64+schroot(Debian bullseye) can’t
run</a></p>
<p><a
href="https://www.mail-archive.com/qemu-devel@nongnu.org/msg992319.html">[PATCH
1/1] linux-user: Add drm ioctls for graphics drivers</a></p>
<p><a
href="https://patchwork.ozlabs.org/project/qemu-devel/patch/CAGUnxtDAx3RxHbc4LcL3tTtVjRfL4GMhkAjP-pPrQNKaVox_YQ@mail.gmail.com/">[1/1]
Add support for DRM IOCTLs to QEMU user mode virtualization.</a></p>
<p><a
href="https://www.mail-archive.com/qemu-devel@nongnu.org/msg992319.html">[PATCH
1/1] linux-user: Add drm ioctls for graphics drivers</a></p>
<p><a
href="https://patchwork.kernel.org/project/qemu-devel/cover/20230410101118.59564-1-tanxiongchuan@isrc.iscas.ac.cn/">[0/3]
linux-user: Add some ioctls for mesa amdgpu support</a></p>
<p>When we start QEMU emulated Furmark it will takes minutes, draw a
window and then it will crash entire QEMU for some reason. I wasn’t able
to to find the problem, it may be caused by a bug in the C library
itself. QEMU is using something like blocks of translated code and it
switches between them with a <a
href="https://man7.org/linux/man-pages/man3/longjmp.3p.html"><code>longjump()</code>
call</a>.</p>
<p>This function can return from the innermost code (function which
called function which called another function) into a previously defined
return point. It saves time, because we don’t need to react on return
from each level and we can just skip them. There is also a variant
called <code>siglongjmp()</code> which can work with signals too. And
that’s a problem. Furmark is using SIGALARM to sample a second (I
think). In this case the return of <code>siglongjmp()</code> fails and
the code continues at the wrong place which is detected by QEMU engine,
which crashes.</p>
<p>I wasn’t able to fix this issue, but one option still remains. Usualy
the easiest one. Just ask the maintainer of Furmark to make a linux
32-bit version too :-D.</p>
<p>And voila <a href="https://www.geeks3d.com/dl/show/733">it
happened</a>:</p>
<p>So let’s copy the application on the drive and start it.</p>
<pre><code>/opt/FurMark_linux32/furmark --demo furmark-gl --gpu-index 0 --width 1920 --height 1080
ATTENTION: default value of option vblank_mode overridden by environment.
Illegal instruction</code></pre>
<p>Nope we received an SIGILL crash! If we disassemble the binary with
objdump it looks like a lot of SSE instructions is used:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ex">objdump</span> <span class="at">-d</span> FurMark_linux32/dylibs/<span class="pp">*</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;cmov\|fucomi&quot;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">453eb7:</span>   0f 48 c2                cmovs  %edx,%eax</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">45a531:</span>   0f 4e 45 1c             cmovle 0x1c<span class="er">(</span><span class="ex">%ebp</span><span class="kw">)</span><span class="ex">,%eax</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">462473:</span>   0f 46 c2                cmovbe %edx,%eax</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="ex">463a53:</span>   0f 4d 45 ec             cmovge <span class="at">-0x14</span><span class="er">(</span><span class="ex">%ebp</span><span class="kw">)</span><span class="ex">,%eax</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">4655f9:</span>   0f 46 c2                cmovbe %edx,%eax</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">4f12f8:</span>   0f 42 c2                cmovb  %edx,%eax</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">50fee1:</span>   df e9                   fucomip %st<span class="er">(</span><span class="ex">1</span><span class="kw">)</span><span class="ex">,%st</span></span></code></pre></div>
<p>We are screwed!</p>
<p>Or are we?</p>
<p>Well asking the maintainer to rebuild for 486 (and using a 486
precompiled compiler as modern ones have already some i686 code in
precompiled functions) or asking for the Furmark source code would
probably count as an abuse, but there is another - more adventurous
way.</p>
<h3 id="opcode-exceptions">Opcode exceptions</h3>
<p>If x86 CPU detects an unknown future instruction (or just random
bytes) it will throw an exception. An operating system should analyze
the opcode and then terminate the application (or in case of MSDOS reset
the system :-D). This mechanism is what will print out SIGILL. But it
doesn’t need to be. Even 486 BIOS should be able to emulate some
opcodes. I think I saw <code>loadall 286</code> algorithm somewhere. And
ofcourse it is used to emulate FPU instructions too. Thanksfully it
seems no MMX instructions was compiled in, so we need only to somehow
emulate CMOV and FUCOMI.</p>
<p>We are in luck again somebody already tried that:</p>
<p><a href="https://lwn.net/Articles/3874/">“CMOV emulation for
2.4.19-rc1”</a></p>
<p><a
href="https://lore.kernel.org/lkml/202106272120.07140.linux@zary.sk/T/">“x86:
add NOPL and CMOV emulation”</a></p>
<p>There is already an emulation for FPU i686 enhancements for years. If
somebody used 486SX there wouldn’t be any problem with i686 level
programs. The application would failed only with 486DX, which is also
using the native FPU.</p>
<p>The CMOV discussion dropped the patch because on pentium and above
some unsupported instructions won’t raise the exceptions (thus cannot be
catched and emulated), but 486 is old enough and will always fail. All
we need to do is to implant the patch into our kernel snapshot and
everytime CMOV or FUCOMI opcode is detected the exception handler with
analyze the code and it will emulate the behaviour. It will be obviously
a lot of slower than a native support.</p>
<p>Technically we could emulate even MMX and SSE, but that would
practically lead to something like QEMU (hopefully without siglongjmp
calls). If anybody with an extensive linux knowledge want to make a dent
in retrohistory, feel free :-D (it would also enable anybody to use
nvidia opengl drivers on the 486 platform).</p>
<p>Now we can run the furmark again and we should see this:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/WLc0jcW_zbg" title="The Ultimate 486 Upgrade: Running Furmark with CMOV emulation" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>As we can see 486 has a great score of:</p>
<pre><code>[ Demo Quick Stats ]
- demo                 : FurMark(GL) (built-in: YES)
- renderer             : AMD CEDAR (DRM 2.50.0 / 6.3.9-retro+)
- 3D API               : OpenGL 4.5 (Core Profile) Mesa 23.2.1
- frames               : 118
- duration             : 358992 ms
- FPS (min/avg/max)    : 0 / 0 / 2
- resolution           : 1920x1080</code></pre>
<h3 id="opera">Opera</h3>
<p>The last linux version of <a href="https://www.opera.com/">Opera
browser</a> which uses only i486-compatible instructions seems to be <a
href="https://get.opera.com/pub/opera/linux/1101/">11.01 (build
1190)</a>. Since the version <a
href="https://get.opera.com/pub/opera/linux/1110b1/">11.10 (build
2048)</a> (which coincides with a new version of the Presto rendering
engine) there seems to be a lot of cmov/fucomi usage. This means the
browser won’t run without emulation and as we have one working we can
use it. Another evolution is version <a
href="https://get.opera.com/pub/opera/linux/1210b1/">12.10 (build
1615)</a> and later where SSE and MMX coprocessor instructions
(registers <code>%xmm</code> and <code>%mm</code>) have started to
appear. However it seems the 12.16 starts anyway. It is possible the
SSE/MMX instructions are located only in a specific parts of the binary
(runtime detected video acceleration etc.).</p>
<p>Opera 11.01 Acid3 test:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/T2t2_CDpnyU" title="The Ultimate 486 Upgrade: Opera 11.01 Acid3 test" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Opera 12.16 Acid3 test with emulated i686 instructions:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/B40rCYCAuGU" title="The Ultimate 486 Upgrade: Opera 12.16 Acid3 test" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>It looks like the emulated version takes about twice as long to
finish.</p>
<h3 id="dillo">Dillo</h3>
<p>Even a native Opera runs slow. We can use a lightweight browser
called <a href="https://dillo.org/">Dillo</a>. Sadly it is also limited
in functions.</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/cJwzlpZePSs" title="The Ultimate 486 Upgrade: Dillo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h3 id="blender">Blender</h3>
<p>My last experiment <a href="https://youtu.be/90yZvbou7HY">Vocore2
performance tests: Blender</a> worked on a similar memory constrained
machine. Now we can try to run it on a 486. The Blender compilation was
configured to have almost every feature disabled. The result looks like
this:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/_K-unueb1SM" title="The Ultimate 486 Upgrade: Blender teapot" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>If you need input to be available, you will need to enable python
support.</p>
<h1 id="other-shenigans">Other shenigans</h1>
<p>It is still possible to expand these experiments more. Literally
expand.</p>
<h2 id="pcie-port-expander">PCIe port expander</h2>
<p>I bought this device few years ago while <a
href="https://www.abclinuxu.cz/blog/GardenOfEdenConfiguration/2019/10/opus-magnum">trying
to put an AMD radeon in a router SoC</a>.</p>
<figure>
<img src="./images/pcie_4_board_main_small.png"
title="PCIe port expander" alt="PCIe port expander" />
<figcaption aria-hidden="true">PCIe port expander</figcaption>
</figure>
<p>The PCIe port expander is just a special PCI-PCI bridge, which has
one upstream (to the host) port and multiple of downstream (to a device)
ports. Originally the boaard was most likely designed to connect
multiple GPU cards into a mining rig. There is no reason for it to not
work in a 486 machine with a similar purpose, so behold a 486
<strong>HYDRA</strong> setup:</p>
<figure>
<img src="./images/hydra_experiment.jpg" title="Experiment hydra"
alt="Experiment hydra" />
<figcaption aria-hidden="true">Experiment hydra</figcaption>
</figure>
<p>This supermultihead (aka hydra) configuration doesn’t have any use. I
don’t even have nearly enough monitors to test it. It cannot be even
used for any OpenCL computation as the linux needs LLVM to use OpenCL to
compile GPU kernels and it wouldn’t fit into RAM at all (somebody can
try it though).</p>
<p>Also it is a pure luck there is enough PCI region space memory. There
are chipsets, which would made this impossible. For example FinALI
doesn’t implement CPU address bits 27 to 30 and it is limited only to
addressing a maximum of 128MB RAM and 128MB of PCI space (it can be more
if there is less of the RAM - but it won’t be continuous). Modern GPUs
starts at 256MB PCI BARs (luckily RX460 can be modified to request
less). But on FinALI it doesn’t matter as it cannot operate in a
busmaster mode anyway.</p>
<p>On UM8881/6 we will get this result:</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/UlhfwlzpMb8" title="The Ultimate 486 Upgrade: Experiment Hydra" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h2 id="network-benchmark">Network benchmark</h2>
<p>Two ethernet cards ware tested a generic realtek RTL8139D and 3com
3C905C Etherlink. The benchmark consisted of an iperf3 server instance,
which was started on 486 (10.0.0.86) and an iperf3 client on the host
machine (10.0.0.1). The second benchmark was done via netcat and pipe
viewer.</p>
<p>Measured results from the host machine for the RTL8139D card:</p>
<pre><code>Connecting to host 10.0.0.86, port 5201
[  5] local 10.0.0.1 port 55676 connected to 10.0.0.86 port 5201
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  1.88 MBytes  15.7 Mbits/sec    9   33.9 KBytes
[  5]   1.00-2.00   sec  1.88 MBytes  15.7 Mbits/sec   17   26.9 KBytes
[  5]   2.00-3.00   sec  2.12 MBytes  17.8 Mbits/sec   12   26.9 KBytes
[  5]   3.00-4.00   sec  1.88 MBytes  15.7 Mbits/sec   13   28.3 KBytes
[  5]   4.00-5.00   sec  1.88 MBytes  15.7 Mbits/sec    8   28.3 KBytes
[  5]   5.00-6.00   sec  1.88 MBytes  15.7 Mbits/sec   13   35.4 KBytes
[  5]   6.00-7.00   sec  1.88 MBytes  15.7 Mbits/sec   14   32.5 KBytes
[  5]   7.00-8.00   sec  2.00 MBytes  16.8 Mbits/sec   11   31.1 KBytes
[  5]   8.00-9.00   sec  2.00 MBytes  16.8 Mbits/sec   11   35.4 KBytes
[  5]   9.00-10.00  sec  1.88 MBytes  15.7 Mbits/sec    8   33.9 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  19.2 MBytes  16.1 Mbits/sec  116             sender
[  5]   0.00-10.01  sec  19.1 MBytes  16.0 Mbits/sec                  receiver</code></pre>
<p>Measured results from the host machine for the 3com 3C905C Etherlink
card:</p>
<pre><code>Connecting to host 10.0.0.86, port 5201
[  5] local 10.0.0.1 port 43870 connected to 10.0.0.86 port 5201
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  3.62 MBytes  30.4 Mbits/sec    7   56.6 KBytes
[  5]   1.00-2.00   sec  3.25 MBytes  27.3 Mbits/sec    2   58.0 KBytes
[  5]   2.00-3.00   sec  3.38 MBytes  28.3 Mbits/sec    3   60.8 KBytes
[  5]   3.00-4.00   sec  3.38 MBytes  28.3 Mbits/sec    2   66.5 KBytes
[  5]   4.00-5.00   sec  3.25 MBytes  27.3 Mbits/sec    5   49.5 KBytes
[  5]   5.00-6.00   sec  3.50 MBytes  29.4 Mbits/sec    3   50.9 KBytes
[  5]   6.00-7.00   sec  3.25 MBytes  27.3 Mbits/sec    3   55.1 KBytes
[  5]   7.00-8.00   sec  3.38 MBytes  28.3 Mbits/sec    2   58.0 KBytes
[  5]   8.00-9.00   sec  3.38 MBytes  28.3 Mbits/sec    2   63.6 KBytes
[  5]   9.00-10.00  sec  3.50 MBytes  29.4 Mbits/sec    3   65.0 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  33.9 MBytes  28.4 Mbits/sec   32             sender
[  5]   0.00-9.95   sec  33.6 MBytes  28.3 Mbits/sec                  receiver</code></pre>
<p>It seems 3com card is almost twice as fast as the realtek one. The
similar results was obtained from multiple realtek cards.</p>
<h2 id="windows">Windows</h2>
<p>It seems the retro community has a fondness of closed source
operating systems, why not to make a SeaBIOS validation experiment by
installing Win 2000 or some older Windows version.</p>
<p>First we need to burn a CDROM image and connect a drive the the
system. For some reason the detection of CDROM/DVD in SeaBIOS is really
slow, but eventually/after few tries it should start booting. There is a
small problem the boot order is not implemented yet and the installer
may get confused what is and what is not an HDD. For me it was fixed
just by rebooting.</p>
<p>Another problem is SeaBIOS missing PIT (timer) initializations and
some MSDOS applications will wait on one of the timer to overflow as a
part of their waiting loop. This will lead to freezing the installation
of windows 98SE. I think <code>mode.com</code> program is using it
during the boot.</p>
<p>If the install doesn’t fail we should be able to get into the
desktop. Sadly there won’t be any drivers for any modern GPU. Actually
there is a driver for ATI HD5450, which was backported from win XP, but
the situation is as expected a minimum required CPU generation which
supports SSE, CMOV etc.</p>
<p>I really don’t like poking inside Windows so I won’t be fixing that.
There are few possible ways: Modifying ATI radeon drivers to rewrite
i686+ instructions with only ones available on i486 (possible, but there
is lot’s of libraries to modify). Adding the emulation to the Windows
kernel (probably easier, but you need to poke inside windows kernel).
Another way (and the prefered one) would be to port Mesa3D to windows
:-D. And finally: not using Windows at all and doing the same work in
ReactOS. It is opensourced and the result would be a modern Windows API
(not sure what versions do they support, win11 ?) on 486 machine.</p>
<p>Installing a general VBE driver didn’t work, either there was a black
screen of the windows crashed with BSOD buring the boot (same when it
crashes with installed ATI radeon driver). Windows must be then either
started in the safe mode or reverted to the last working state. BTW I
must say disabling the serial mouse in the safe mode is an evil dead!
(even worse, PS/2 mouse doesn’t get disabled).</p>
<p>Generic VGA works well, but it offers only 640x480. But still I was
able do a few experiments with that:</p>
<figure>
<img src="./images/cinebench_running.png" title="Cinebench 2k running"
alt="Cinebench 2k running" />
<figcaption aria-hidden="true">Cinebench 2k running</figcaption>
</figure>
<figure>
<img src="./images/cinebench_finished.png" title="Cinebench 2k finished"
alt="Cinebench 2k finished" />
<figcaption aria-hidden="true">Cinebench 2k finished</figcaption>
</figure>
<figure>
<img src="./images/hwinfo1.png" title="HWinfo left" alt="HWinfo left" />
<figcaption aria-hidden="true">HWinfo left</figcaption>
</figure>
<figure>
<img src="./images/hwinfo2.png" title="HWinfo right"
alt="HWinfo right" />
<figcaption aria-hidden="true">HWinfo right</figcaption>
</figure>
<figure>
<img src="./images/hwinfo_cinebench.png"
title="HWinfo and Cinebench 2k together"
alt="HWinfo and Cinebench 2k together" />
<figcaption aria-hidden="true">HWinfo and Cinebench 2k
together</figcaption>
</figure>
<p>Now the cinebench 2k contest can have another <em>weird</em>
entry:</p>
<pre><code>Cinebench 2000 V1.0 Performance
****************************************************

Tester           : &lt;fill this out&gt;

Processor        : &lt;fill this out&gt;
Number of CPUs   : 1
Physical Memory  : &lt;fill this out&gt;
Operating System : &lt;fill this out&gt;

Graphic Card     : &lt;fill this out&gt;
Resolution       : &lt;fill this out&gt;
Color Depth      : &lt;fill this out&gt;

****************************************************

Shading (CINEMA 4D)      : 0.46 CB
Shading (OpenGL)         : 0.23 CB
Raytracing (Single   CPU): 0.22 CB
Raytracing (Multiple CPU): --- CB

OpenGL Shading is 1.97 times slower than CINEMA 4D Shading!

****************************************************</code></pre>
<p>The results had to be printscreened segment by segment and stored in
ms paint as a bitmap. I didn’t stitched the segments together so the
real pain of working with too big windows in 640x480 resolution can be
seen by everybody :-P.</p>
<h2 id="lower-bound">Lower bound</h2>
<p>For few years where still would be a compatibility of the modern GPU
with the old PCI protocol, so any up to date GPU could be probably able
to run in the 486 machine. And if not during the boot in SeaBIOS (for
example because of removed option ROM support and relying only on UEFI),
the linux driver would be able run the inicialization. There is still a
question:</p>
<p>Is the 486 motherboard the <em>oldest</em> system which can support
PCIe?</p>
<p>I don’t plan to explore this path, but when I was researching PCI
chipsets I’ve found <a
href="http://www.bitsavers.org/components/opti/dataSheets/82C822_VESA_to_PCI_Apr94.pdf">the
OPTi 82C822 “VESA local bus to PCI bridge”</a>. It was used as an IBM
custom designed VLB riser board and it did exactly that. One of two (?)
versions of the riser can be shown in Epictronics’s video (around
8:45):</p>
<iframe width="50%" height="50%" src="https://www.youtube.com/embed/UBfS_sDtpn8?start=525" title="IBM 350-466DX2 Rescued with Computer Reset part. Can we make it play Grand Theft Auto in High Color?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>If the card was converted to a regular VLB card or a new VLB card was
made, it could be possible to use it in for example a 386 board. I think
there were even 386sx VLB boards?</p>
<p>I will leave this topic open &gt;-D.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Finally we are at the end of this monstrous experiment. Do you think
it was worth it? :-D</p>
<p>During the development there was a lot of suffering, especially
guessing if L2 cache will initialize or it will crash the system (or
more likely how should L2 cache initialize). But over all the feeling of
being the only guy in the world with working PCIe GPU in a 486 system
was nice \m/.</p>
<p>Also it spawned the reversed engineered UMC datasheet (thanks to guys
at Vogons forum).</p>
<p>There is still a lot of bugs, not sure if I gonna continue with the
project, maybe in the basis “I want to boot from this different mobo and
there is no CDROM support in the BIOS”.</p>
<p>Also the FinALI support in Coreboot/SeaBIOS is probably not working
now (with all the UMC changes). There could be an SiS496/7 support
implemented and I even have a (damaged) board, but I don’t have any time
(it should be easier to do that when UMC support can be used as an
inspiration). Intel 486 chipsets will be added only if somebody gives me
a working board (well maybe not even then &gt;-D).</p>
<p>Possible improvements of the coreboot would be ACPI (there wasn’t
much space left in the BIOS chip to implement that). Also coreboot
should be merged with SeaBIOS (but SeaBIOS has a really poor code
architecture). It would saved a lot of code though. Oh also a CMOS setup
UI would be nice.</p>
<p>Best regards and keep hacking,</p>
<p>pc2005</p>
<p>P.S. If any UMC representative reads this: disclose your UM8881/6
chipset datasheet :-P</p>
<p>P.P.S. I won’t post here my bitcoin address
(<code>16odFaRLqvfRNfsoewjV3rDB1jh2JyV4Ge</code>) as nobody donates
anyway but if you like this work and you want to help the author you can
always try to push the UMC to reveal the datasheet &gt;-D. You can also
add the support for your board or do more reverse engineering of the UMC
chipset registers yourself. And if you really want to send a donation
you can help the development of a reverse engineering tools <a
href="https://www.radare.org/r/me.html">Radare</a>, the development of
the <a
href="https://www.patreon.com/slackwarelinux/overview">distribution
which I use</a> or effectively any project which was used here. Also you
can donat to a <a
href="https://standwithukraine.com.ua/donation/">completely different
cause</a>.</p>
